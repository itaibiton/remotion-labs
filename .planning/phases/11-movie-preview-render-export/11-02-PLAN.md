---
phase: 11-movie-preview-render-export
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/renders.ts
  - convex/triggerRender.ts
  - convex/movies.ts
  - convex/clips.ts
  - convex/lib/renderLimits.ts
autonomous: true

must_haves:
  truths:
    - "User can render the full movie to a single MP4 and download it"
    - "Movie render progress is tracked and visible to the user"
    - "startClipRender action exists to render individual DynamicCode clips to MP4 via Lambda"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Updated renders table with optional generationId and optional movieId"
      contains: "movieId.*v.optional.*v.id.*movies"
    - path: "convex/renders.ts"
      provides: "Updated create mutation accepting either generationId or movieId"
      exports: ["create", "update", "get", "getByGeneration", "getByMovie"]
    - path: "convex/triggerRender.ts"
      provides: "startMovieRender and startClipRender actions for Lambda rendering"
      exports: ["startRender", "startMovieRender", "startClipRender", "pollProgress"]
    - path: "convex/movies.ts"
      provides: "Internal getWithClipsInternal query for action use"
      exports: ["getWithClipsInternal"]
    - path: "convex/lib/renderLimits.ts"
      provides: "MOVIE_RENDER_LIMITS with higher timeout and duration caps"
      exports: ["RENDER_LIMITS", "MOVIE_RENDER_LIMITS"]
  key_links:
    - from: "convex/triggerRender.ts"
      to: "convex/movies.ts"
      via: "ctx.runQuery(internal.movies.getWithClipsInternal)"
      pattern: "getWithClipsInternal"
    - from: "convex/triggerRender.ts"
      to: "convex/renders.ts"
      via: "ctx.runMutation(internal.renders.create) with movieId"
      pattern: "movieId.*args\\.movieId"
    - from: "convex/triggerRender.ts"
      to: "convex/lib/renderLimits.ts"
      via: "MOVIE_RENDER_LIMITS constants"
      pattern: "MOVIE_RENDER_LIMITS"
---

<objective>
Build the backend pipeline for rendering full movies to MP4 via Remotion Lambda.

Purpose: This creates the server-side infrastructure needed to render multi-scene movies as a single MP4 video. It updates the schema to support movie renders (not just single-generation renders), adds higher limits for movies, and creates the startMovieRender action.

Output: Updated renders schema, MOVIE_RENDER_LIMITS, internal movie query for actions, and startMovieRender action with Lambda integration + progress polling.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-movie-preview-render-export/11-RESEARCH.md
@convex/schema.ts
@convex/renders.ts
@convex/triggerRender.ts
@convex/movies.ts
@convex/lib/renderLimits.ts
@convex/userQuotas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update schema, render limits, renders CRUD, and internal movie query</name>
  <files>
    convex/schema.ts
    convex/lib/renderLimits.ts
    convex/renders.ts
    convex/movies.ts
  </files>
  <action>
  Modify `convex/schema.ts` -- renders table:
  - Change `generationId: v.id("generations")` to `generationId: v.optional(v.id("generations"))`
  - Add `movieId: v.optional(v.id("movies"))` field
  - Add index: `.index("by_movie", ["movieId"])`
  - Keep all existing fields and indexes unchanged

  Modify `convex/lib/renderLimits.ts`:
  - Keep existing `RENDER_LIMITS` unchanged
  - Add new export `MOVIE_RENDER_LIMITS`:
    ```
    export const MOVIE_RENDER_LIMITS = {
      MAX_DURATION_SECONDS: 120,
      MAX_DURATION_FRAMES: 120 * 30, // 3600 frames at 30fps
      LAMBDA_TIMEOUT_MS: 240000, // 4 minutes
      POLL_INTERVAL_MS: 3000, // 3 seconds (slightly longer for movies)
      MAX_SCENES: 20, // Scene count limit
    } as const;
    ```

  Modify `convex/renders.ts`:
  - Update `create` internal mutation args: change `generationId: v.id("generations")` to `generationId: v.optional(v.id("generations"))`, add `movieId: v.optional(v.id("movies"))`
  - Add `getByMovie` public query:
    ```
    export const getByMovie = query({
      args: { movieId: v.id("movies") },
      handler: async (ctx, args) => {
        return await ctx.db
          .query("renders")
          .withIndex("by_movie", (q) => q.eq("movieId", args.movieId))
          .order("desc")
          .first();
      },
    });
    ```

  Modify `convex/movies.ts`:
  - Add import for `internalQuery` from `./_generated/server`
  - Add `getWithClipsInternal` internal query (same logic as `getWithClips` but using `internalQuery` so it can be called from actions):
    ```
    export const getWithClipsInternal = internalQuery({
      args: { id: v.id("movies") },
      handler: async (ctx, args) => {
        const movie = await ctx.db.get(args.id);
        if (!movie) return null;
        const clips = await Promise.all(
          movie.scenes.map((scene) => ctx.db.get(scene.clipId))
        );
        return { ...movie, sceneClips: clips };
      },
    });
    ```
  </action>
  <verify>
  Run `npx convex dev --once` (or `npx tsc --noEmit` on the convex directory) to confirm schema and type changes are valid. No Convex deployment errors. Verify the renders table schema allows both generationId-only (existing clip renders) and movieId-only (new movie renders) records.
  </verify>
  <done>
  Renders schema supports optional generationId and optional movieId. MOVIE_RENDER_LIMITS exported with 120s max duration, 240s Lambda timeout, 20 scene max. getByMovie query exists. getWithClipsInternal internal query exists for action use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create startMovieRender action with Lambda integration</name>
  <files>
    convex/triggerRender.ts
  </files>
  <action>
  Add `startMovieRender` action to `convex/triggerRender.ts`:

  - Import `MOVIE_RENDER_LIMITS` from `./lib/renderLimits`
  - Import `internal` (already imported)
  - Action args: `{ movieId: v.id("movies") }`
  - Return type: `Promise<{ renderJobId: Id<"renders">; renderId: string }>`
  - Handler logic:
    1. Verify authentication (`ctx.auth.getUserIdentity()`, throw if null)
    2. Check render quota via `ctx.runMutation(internal.userQuotas.checkRenderQuota, { userId: identity.tokenIdentifier })` -- same as startRender
    3. Fetch movie: `ctx.runQuery(internal.movies.getWithClipsInternal, { id: args.movieId })` -- throw if null
    4. Build scenes array: filter out null clips from `movie.sceneClips`, map to `{ code: clip.code, durationInFrames: clip.durationInFrames, fps: clip.fps }`
    5. Validate: throw if scenes.length === 0 ("Movie has no valid scenes")
    6. Validate: throw if scenes.length > MOVIE_RENDER_LIMITS.MAX_SCENES
    7. Compute totalFrames, validate against MOVIE_RENDER_LIMITS.MAX_DURATION_FRAMES
    8. Call `renderMediaOnLambda` with:
       - composition: "MovieComposition"
       - inputProps: `{ scenes }` (the filtered scenes array)
       - codec: "h264"
       - timeoutInMilliseconds: MOVIE_RENDER_LIMITS.LAMBDA_TIMEOUT_MS
       - Same region/functionName/serveUrl pattern as startRender
    9. Store render job via `ctx.runMutation(internal.renders.create, { userId, movieId: args.movieId, renderId, bucketName, status: "rendering", progress: 0 })`
    10. Schedule polling via `ctx.scheduler.runAfter(MOVIE_RENDER_LIMITS.POLL_INTERVAL_MS, internal.triggerRender.pollProgress, { renderJobId, renderId, bucketName, region })`
    11. Return `{ renderJobId, renderId }`

  The existing `pollProgress` action already handles the progress/complete/failed flow generically -- it does NOT reference generationId, so it works for movie renders unchanged.

  **Also add `startClipRender` action** (for OUT-03 single clip MP4 export):
  - Action args: `{ clipId: v.id("clips") }`
  - Handler logic:
    1. Auth check (same pattern)
    2. Quota check (same pattern)
    3. Fetch clip: `ctx.runQuery(internal.clips.getInternal, { id: args.clipId })` -- add `getInternal` internalQuery to `convex/clips.ts` (same pattern as getWithClipsInternal: just `ctx.db.get(args.id)`)
    4. Validate clip exists, validate duration against RENDER_LIMITS (single clip limits, not movie limits)
    5. Call `renderMediaOnLambda` with composition: "DynamicCode", inputProps: `{ code: clip.code, durationInFrames: clip.durationInFrames, fps: clip.fps }`, codec: "h264", timeoutInMilliseconds: RENDER_LIMITS.LAMBDA_TIMEOUT_MS
    6. Store render job via `ctx.runMutation(internal.renders.create, { userId, generationId: undefined, renderId, bucketName, status: "rendering", progress: 0 })` (no generationId or movieId -- this is a clip render)
    7. Schedule polling, return `{ renderJobId, renderId }`
  - Add `clipId: v.optional(v.id("clips"))` to the renders schema (alongside optional generationId and movieId) so clip renders can be tracked
  - Add `getInternal` internalQuery export to `convex/clips.ts`
  </action>
  <verify>
  Run `npx tsc --noEmit` -- no type errors. Verify both `startMovieRender` and `startClipRender` are exported from triggerRender.ts. Verify accessible via `api.triggerRender.startMovieRender` and `api.triggerRender.startClipRender`.
  </verify>
  <done>
  startMovieRender and startClipRender actions both exist. startMovieRender handles multi-scene movies, startClipRender handles individual DynamicCode clips. Both follow the same Lambda render pattern with appropriate limits.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Schema changes are backward-compatible (existing renders still work with optional generationId)
3. startMovieRender action is callable with a movieId and returns renderJobId + renderId
4. startClipRender action is callable with a clipId and returns renderJobId + renderId
5. pollProgress works unchanged for movie and clip renders (no generationId dependency)
6. MOVIE_RENDER_LIMITS are reasonable: 120s video, 240s Lambda timeout, 20 scenes max
</verification>

<success_criteria>
- Renders table schema supports clip renders (generationId), movie renders (movieId), and standalone clip renders (clipId)
- MOVIE_RENDER_LIMITS exported with higher caps than single-clip RENDER_LIMITS
- startMovieRender action triggers Lambda with MovieComposition composition and scenes as inputProps
- startClipRender action triggers Lambda with DynamicCode composition and clip code as inputProps
- getWithClipsInternal and getInternal internal queries available for action use
- getByMovie query enables UI to track movie render status
- TypeScript compiles, no Convex deployment errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-movie-preview-render-export/11-02-SUMMARY.md`
</output>

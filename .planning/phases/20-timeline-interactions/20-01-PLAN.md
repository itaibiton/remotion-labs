---
phase: 20-timeline-interactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/movies.ts
  - src/components/movie/timeline-trim-handle.tsx
  - src/components/movie/timeline-scene.tsx
  - src/components/movie/timeline.tsx
  - src/components/movie/movie-composition.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag a handle on the left edge of a clip to trim its start"
    - "User can drag a handle on the right edge of a clip to trim its end"
    - "Trimmed clip visually shrinks on the timeline"
    - "Preview respects trimmed frame range (skips trimStart frames)"
    - "Dragging center of clip still reorders (drag/trim separation works)"
  artifacts:
    - path: "convex/schema.ts"
      provides: "trimStart/trimEnd fields on scene object"
      contains: "trimStart: v.optional(v.number())"
    - path: "convex/movies.ts"
      provides: "trimScene mutation"
      exports: ["trimScene"]
    - path: "src/components/movie/timeline-trim-handle.tsx"
      provides: "TrimHandle component with pointer events"
      min_lines: 40
    - path: "src/components/movie/timeline-scene.tsx"
      provides: "setActivatorNodeRef pattern separating drag from trim"
      contains: "setActivatorNodeRef"
  key_links:
    - from: "src/components/movie/timeline-scene.tsx"
      to: "src/components/movie/timeline-trim-handle.tsx"
      via: "TrimHandle component import"
      pattern: "import.*TrimHandle"
    - from: "src/components/movie/timeline.tsx"
      to: "convex/movies.ts"
      via: "useMutation for trimScene"
      pattern: "useMutation.*trimScene"
    - from: "src/components/movie/movie-composition.tsx"
      to: "remotion Sequence"
      via: "from={-trimStart} for frame offset"
      pattern: "from=\\{-.*trimStart"
---

<objective>
Implement non-destructive trim handles on timeline clips with schema support

Purpose: Allow users to adjust clip in/out points by dragging handles on clip edges, without modifying the original clip data. This is the foundation for professional-grade timeline editing.

Output:
- Schema updated with trimStart/trimEnd fields
- trimScene mutation for persisting trim changes
- TrimHandle component using pointer events pattern (same as playhead)
- TimelineScene updated with setActivatorNodeRef to separate drag from trim
- MovieComposition updated to respect trim values via Remotion Sequence from prop
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-timeline-interactions/20-RESEARCH.md
@.planning/phases/19-timeline-foundation/19-02-SUMMARY.md

Source files:
@convex/schema.ts
@convex/movies.ts
@src/components/movie/timeline-scene.tsx
@src/components/movie/timeline.tsx
@src/components/movie/timeline-playhead.tsx
@src/components/movie/movie-composition.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trimStart/trimEnd to schema and create trimScene mutation</name>
  <files>convex/schema.ts, convex/movies.ts</files>
  <action>
Update convex/schema.ts:
- Add trimStart and trimEnd to the scene object inside movies table:
  ```typescript
  scenes: v.array(v.object({
    clipId: v.id("clips"),
    durationOverride: v.optional(v.number()),
    trimStart: v.optional(v.number()),  // Frames to skip from start (default 0)
    trimEnd: v.optional(v.number()),    // Frames to cut from end (default 0)
  })),
  ```

Update convex/movies.ts:
- Update `computeTotalDuration` helper to account for trim values:
  ```typescript
  async function computeTotalDuration(
    ctx: { db: { get: (id: any) => Promise<any> } },
    scenes: Array<{ clipId: any; durationOverride?: number; trimStart?: number; trimEnd?: number }>
  ): Promise<number> {
    let total = 0;
    for (const scene of scenes) {
      let baseDuration: number;
      if (scene.durationOverride) {
        baseDuration = scene.durationOverride;
      } else {
        const clip = await ctx.db.get(scene.clipId);
        baseDuration = clip?.durationInFrames ?? 0;
      }
      const trimStart = scene.trimStart ?? 0;
      const trimEnd = scene.trimEnd ?? 0;
      total += Math.max(0, baseDuration - trimStart - trimEnd);
    }
    return total;
  }
  ```

- Add trimScene mutation:
  ```typescript
  export const trimScene = mutation({
    args: {
      movieId: v.id("movies"),
      sceneIndex: v.number(),
      trimStart: v.optional(v.number()),
      trimEnd: v.optional(v.number()),
    },
    handler: async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) throw new Error("Not authenticated");

      const movie = await ctx.db.get(args.movieId);
      if (!movie || movie.userId !== identity.tokenIdentifier) {
        throw new Error("Movie not found");
      }

      const scene = movie.scenes[args.sceneIndex];
      if (!scene) throw new Error("Scene not found");

      // Get base duration for validation
      const clip = await ctx.db.get(scene.clipId);
      const baseDuration = scene.durationOverride ?? clip?.durationInFrames ?? 0;
      const trimStart = args.trimStart ?? scene.trimStart ?? 0;
      const trimEnd = args.trimEnd ?? scene.trimEnd ?? 0;

      // Validate: trim values must be non-negative
      if (trimStart < 0 || trimEnd < 0) {
        throw new Error("Trim values must be non-negative");
      }
      // Validate: effective duration must be at least 1 frame
      if (trimStart + trimEnd >= baseDuration) {
        throw new Error("Trim would result in zero or negative duration");
      }

      // Update scene with new trim values
      const newScenes = [...movie.scenes];
      newScenes[args.sceneIndex] = {
        ...scene,
        trimStart: args.trimStart ?? scene.trimStart,
        trimEnd: args.trimEnd ?? scene.trimEnd,
      };

      const totalDuration = await computeTotalDuration(ctx, newScenes);

      await ctx.db.patch(args.movieId, {
        scenes: newScenes,
        totalDurationInFrames: totalDuration,
        updatedAt: Date.now(),
      });
    },
  });
  ```

- Update reorderScenes args to include trimStart/trimEnd in sceneOrder validation.
  </action>
  <verify>npx convex dev runs without errors (schema is valid)</verify>
  <done>Schema has trimStart/trimEnd fields; trimScene mutation exists and validates bounds</done>
</task>

<task type="auto">
  <name>Task 2: Create TrimHandle component and update TimelineScene with setActivatorNodeRef</name>
  <files>src/components/movie/timeline-trim-handle.tsx, src/components/movie/timeline-scene.tsx</files>
  <action>
Create src/components/movie/timeline-trim-handle.tsx:
- Use the SAME pointer capture pattern as timeline-playhead.tsx
- Props: side ("left" | "right"), onTrimDelta (callback with frame delta during drag), onTrimEnd (callback when drag ends), pixelsPerFrame (for conversion), maxTrimFrames (limit how far can trim), currentTrimFrames (for restore limit)
- Implementation:
  ```typescript
  "use client";

  import { useState, useRef } from "react";

  interface TrimHandleProps {
    side: "left" | "right";
    onTrimDelta: (deltaFrames: number) => void;
    onTrimEnd: () => void;
    pixelsPerFrame: number;
    maxTrimFrames: number;
    currentTrimFrames: number;
  }

  export function TrimHandle({
    side,
    onTrimDelta,
    onTrimEnd,
    pixelsPerFrame,
    maxTrimFrames,
    currentTrimFrames,
  }: TrimHandleProps) {
    const [isDragging, setIsDragging] = useState(false);
    const startXRef = useRef(0);
    const accumulatedDeltaRef = useRef(0);

    const handlePointerDown = (e: React.PointerEvent) => {
      e.stopPropagation(); // Prevent @dnd-kit activation
      e.preventDefault();
      e.currentTarget.setPointerCapture(e.pointerId);
      setIsDragging(true);
      startXRef.current = e.clientX;
      accumulatedDeltaRef.current = 0;
    };

    const handlePointerMove = (e: React.PointerEvent) => {
      if (!isDragging) return;
      const deltaX = e.clientX - startXRef.current;
      // For left handle: positive deltaX = more trim (shrink start)
      // For right handle: negative deltaX = more trim (shrink end)
      const rawDeltaFrames = Math.round(deltaX / pixelsPerFrame);
      const effectiveDelta = side === "left" ? rawDeltaFrames : -rawDeltaFrames;

      // Clamp: can't trim more than maxTrimFrames, can't restore more than currentTrimFrames
      const clampedDelta = Math.max(
        -currentTrimFrames, // Can restore up to current trim
        Math.min(maxTrimFrames, effectiveDelta) // Can trim up to max
      );

      if (clampedDelta !== accumulatedDeltaRef.current) {
        onTrimDelta(clampedDelta - accumulatedDeltaRef.current);
        accumulatedDeltaRef.current = clampedDelta;
      }
    };

    const handlePointerUp = (e: React.PointerEvent) => {
      if (!isDragging) return;
      e.currentTarget.releasePointerCapture(e.pointerId);
      setIsDragging(false);
      onTrimEnd();
    };

    return (
      <div
        className={`absolute top-0 bottom-0 w-2 cursor-ew-resize touch-none z-20
          ${side === "left" ? "left-0 rounded-l-lg" : "right-0 rounded-r-lg"}
          ${isDragging ? "bg-primary/50" : "bg-primary/20 hover:bg-primary/40"}
          transition-colors`}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerCancel={handlePointerUp}
      />
    );
  }
  ```

Update src/components/movie/timeline-scene.tsx:
- Import TrimHandle component
- Destructure setActivatorNodeRef from useSortable
- Add trimStart, trimEnd, onTrimChange props to TimelineSceneProps
- Create a center drag handle div that uses setActivatorNodeRef with attributes/listeners
- Add TrimHandle components at left and right edges (NOT inside drag handle)
- Calculate effective duration for display: `baseDuration - trimStart - trimEnd`
- The component structure should be:
  ```tsx
  <div ref={setNodeRef} style={...} className="...">
    {/* Left trim handle - NOT part of drag system */}
    <TrimHandle side="left" ... />

    {/* Center drag area - activates sorting */}
    <div
      ref={setActivatorNodeRef}
      {...attributes}
      {...listeners}
      className="absolute inset-x-2 inset-y-0 cursor-grab active:cursor-grabbing"
    />

    {/* Right trim handle - NOT part of drag system */}
    <TrimHandle side="right" ... />

    {/* Content (thumbnail, info) - unchanged but pointer-events-none */}
    <div className="pointer-events-none">
      ...existing content...
    </div>

    {/* Action buttons with pointer-events-auto */}
    ...existing buttons with stopPropagation...
  </div>
  ```
- Calculate pixelsPerFrame from widthPercent and totalDurationInFrames (passed as prop)
- Pass calculated props to TrimHandle
  </action>
  <verify>npm run build compiles without errors; dev server shows trim handles on clips</verify>
  <done>TrimHandle component exists; TimelineScene uses setActivatorNodeRef pattern with trim handles</done>
</task>

<task type="auto">
  <name>Task 3: Wire trim to Timeline and update MovieComposition for playback</name>
  <files>src/components/movie/timeline.tsx, src/components/movie/movie-composition.tsx</files>
  <action>
Update src/components/movie/timeline.tsx:
- Add trimStart/trimEnd to scene type in TimelineProps
- Add onTrimScene callback prop: `(sceneIndex: number, trimStart?: number, trimEnd?: number) => void`
- Update sceneWidths calculation to use effective duration (accounting for trim)
- Pass trimStart, trimEnd, and onTrimChange handler to TimelineScene
- The onTrimChange handler should:
  1. Accept (index, { trimStart?, trimEnd? }) from TimelineScene
  2. Call onTrimScene(index, trimStart, trimEnd)

Update src/components/movie/movie-editor.tsx (minimal):
- Import useMutation for trimScene from convex/movies
- Create trimScene mutation handler
- Pass onTrimScene prop to Timeline that calls the mutation

Update src/components/movie/movie-composition.tsx:
- Update SceneData interface to include trimStart and trimEnd
- In the Series.Sequence rendering:
  ```tsx
  const trimStart = scene.trimStart ?? 0;
  const trimEnd = scene.trimEnd ?? 0;
  const effectiveDuration = scene.durationInFrames - trimStart - trimEnd;

  return (
    <Series.Sequence key={index} durationInFrames={effectiveDuration}>
      {/* Negative from skips the trimStart frames */}
      <Sequence from={-trimStart}>
        <DynamicCode
          code={scene.code}
          durationInFrames={scene.durationInFrames}
          fps={scene.fps}
        />
      </Sequence>
    </Series.Sequence>
  );
  ```
- Import Sequence from "remotion" (not just Series)
  </action>
  <verify>
1. npm run build compiles without errors
2. Dev server: drag trim handle, clip visually shrinks
3. Dev server: preview player respects trim (skips trimmed frames)
4. Dev server: drag center of clip still reorders correctly
  </verify>
  <done>Trim changes persist to database; preview playback respects trim; drag-to-reorder still works</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx convex dev` runs without errors
2. `npm run build` compiles successfully
3. Timeline clips show trim handles on hover
4. Dragging left trim handle shrinks clip from start
5. Dragging right trim handle shrinks clip from end
6. Preview player skips trimmed frames
7. Dragging center of clip still reorders it (not trimming)
8. Database stores trimStart/trimEnd values
</verification>

<success_criteria>
- Schema includes trimStart/trimEnd on scene objects
- trimScene mutation validates bounds and persists changes
- TrimHandle component uses pointer capture pattern
- TimelineScene separates drag area from trim handles via setActivatorNodeRef
- MovieComposition uses Sequence from={-trimStart} for non-destructive playback
- Trimmed clips show correct effective duration
</success_criteria>

<output>
After completion, create `.planning/phases/20-timeline-interactions/20-01-SUMMARY.md`
</output>

---
phase: 20-timeline-interactions
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/lib/timeline-snap.ts
  - src/components/movie/timeline-snap-indicator.tsx
  - src/components/movie/timeline-trim-handle.tsx
  - src/components/movie/timeline.tsx
autonomous: true

must_haves:
  truths:
    - "During trim operations, clips snap to adjacent clip edges"
    - "During trim operations, clips snap to the playhead position"
    - "Snap indicators (visual guides) appear when a clip edge aligns with a snap target"
    - "Snapping only activates within a visual threshold (8-10 pixels)"
  artifacts:
    - path: "src/lib/timeline-snap.ts"
      provides: "Snap detection logic and target building"
      exports: ["findSnapTarget", "buildSnapTargets"]
      min_lines: 40
    - path: "src/components/movie/timeline-snap-indicator.tsx"
      provides: "Visual snap indicator line component"
      exports: ["SnapIndicator"]
      min_lines: 15
    - path: "src/components/movie/timeline-trim-handle.tsx"
      provides: "Snap integration in trim drag"
      contains: "findSnapTarget"
  key_links:
    - from: "src/components/movie/timeline-trim-handle.tsx"
      to: "src/lib/timeline-snap.ts"
      via: "findSnapTarget import"
      pattern: "import.*findSnapTarget.*from.*timeline-snap"
    - from: "src/components/movie/timeline.tsx"
      to: "src/components/movie/timeline-snap-indicator.tsx"
      via: "SnapIndicator component"
      pattern: "SnapIndicator"
---

<objective>
Implement snapping system for trim operations with visual indicators

Purpose: Professional video editors snap to adjacent clip edges and the playhead for precise alignment. This enables users to create seamless transitions and match clip boundaries exactly.

Output:
- Snap detection utility with threshold-based matching
- Snap target builder that collects adjacent clip edges and playhead position
- Visual snap indicator component (vertical line when snapped)
- TrimHandle integration calling snap detection during drag
- Timeline rendering snap indicator when active
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-timeline-interactions/20-RESEARCH.md
@.planning/phases/20-timeline-interactions/20-01-PLAN.md

Source files to reference after Plan 01 completes:
@src/components/movie/timeline-trim-handle.tsx
@src/components/movie/timeline.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snap detection utilities</name>
  <files>src/lib/timeline-snap.ts</files>
  <action>
Create src/lib/timeline-snap.ts with snap detection logic:

```typescript
/**
 * Timeline snapping utilities for trim and drag operations.
 * Snaps to: adjacent clip edges, playhead position, timeline boundaries.
 */

export type SnapTargetType = "clip-edge" | "playhead" | "timeline-boundary";

export interface SnapTarget {
  frame: number;
  type: SnapTargetType;
  label?: string; // For debugging/accessibility
}

export interface SnapResult {
  snapped: boolean;
  frame: number;
  target: SnapTarget | null;
}

/**
 * Find the nearest snap target within the threshold.
 * Returns the snap target if within threshold, null otherwise.
 *
 * @param currentFrame - The frame position being dragged to
 * @param snapTargets - Array of potential snap targets
 * @param thresholdPx - Snap threshold in pixels
 * @param scale - Current zoom scale (pixels per frame)
 */
export function findSnapTarget(
  currentFrame: number,
  snapTargets: SnapTarget[],
  thresholdPx: number,
  scale: number
): SnapResult {
  const thresholdFrames = thresholdPx / scale;
  let nearestTarget: SnapTarget | null = null;
  let nearestDistance = Infinity;

  for (const target of snapTargets) {
    const distance = Math.abs(currentFrame - target.frame);
    if (distance <= thresholdFrames && distance < nearestDistance) {
      nearestDistance = distance;
      nearestTarget = target;
    }
  }

  if (nearestTarget) {
    return {
      snapped: true,
      frame: nearestTarget.frame,
      target: nearestTarget,
    };
  }

  return {
    snapped: false,
    frame: currentFrame,
    target: null,
  };
}

/**
 * Build snap targets from scene data, playhead, and timeline boundaries.
 * Excludes the scene being edited to prevent self-snapping.
 *
 * @param scenes - Array of scenes with frame offsets
 * @param playheadFrame - Current playhead position in frames
 * @param totalDuration - Total movie duration in frames
 * @param excludeSceneIndex - Index of scene being edited (exclude its edges)
 */
export function buildSnapTargets(
  scenes: Array<{
    startFrame: number;
    endFrame: number;
  }>,
  playheadFrame: number,
  totalDuration: number,
  excludeSceneIndex?: number
): SnapTarget[] {
  const targets: SnapTarget[] = [];

  // Timeline boundaries
  targets.push({ frame: 0, type: "timeline-boundary", label: "Timeline start" });
  targets.push({ frame: totalDuration, type: "timeline-boundary", label: "Timeline end" });

  // Playhead
  targets.push({ frame: playheadFrame, type: "playhead", label: "Playhead" });

  // Clip edges (excluding the scene being edited)
  scenes.forEach((scene, index) => {
    if (index === excludeSceneIndex) return;

    targets.push({
      frame: scene.startFrame,
      type: "clip-edge",
      label: `Clip ${index + 1} start`,
    });
    targets.push({
      frame: scene.endFrame,
      type: "clip-edge",
      label: `Clip ${index + 1} end`,
    });
  });

  return targets;
}

/**
 * Calculate scene frame ranges from scenes array.
 * Accounts for trim values to get effective ranges.
 */
export function calculateSceneFrameRanges(
  scenes: Array<{
    durationInFrames: number;
    trimStart?: number;
    trimEnd?: number;
  }>
): Array<{ startFrame: number; endFrame: number }> {
  const ranges: Array<{ startFrame: number; endFrame: number }> = [];
  let offset = 0;

  for (const scene of scenes) {
    const trimStart = scene.trimStart ?? 0;
    const trimEnd = scene.trimEnd ?? 0;
    const effectiveDuration = scene.durationInFrames - trimStart - trimEnd;

    ranges.push({
      startFrame: offset,
      endFrame: offset + effectiveDuration,
    });

    offset += effectiveDuration;
  }

  return ranges;
}
```
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit src/lib/timeline-snap.ts</verify>
  <done>Snap detection utilities exist with findSnapTarget, buildSnapTargets, calculateSceneFrameRanges</done>
</task>

<task type="auto">
  <name>Task 2: Create SnapIndicator component</name>
  <files>src/components/movie/timeline-snap-indicator.tsx</files>
  <action>
Create src/components/movie/timeline-snap-indicator.tsx:

```typescript
"use client";

import { SnapTargetType } from "@/lib/timeline-snap";

interface SnapIndicatorProps {
  frame: number;
  scale: number;
  type: SnapTargetType;
  visible: boolean;
}

/**
 * Visual indicator line shown when a trim handle snaps to a target.
 * Positioned absolutely within the timeline container.
 * Color varies by snap target type for visual feedback.
 */
export function SnapIndicator({ frame, scale, type, visible }: SnapIndicatorProps) {
  if (!visible) return null;

  // Color based on snap target type
  const colorClass = {
    "clip-edge": "bg-blue-400",
    "playhead": "bg-yellow-400",
    "timeline-boundary": "bg-green-400",
  }[type];

  return (
    <div
      className={`absolute top-0 bottom-0 w-0.5 ${colorClass} pointer-events-none z-40 animate-pulse`}
      style={{
        left: `${frame * scale}px`,
        transform: "translateX(-50%)", // Center the line on the frame
      }}
      role="presentation"
      aria-hidden="true"
    />
  );
}
```
  </action>
  <verify>npm run build compiles without errors</verify>
  <done>SnapIndicator component exists with type-based coloring</done>
</task>

<task type="auto">
  <name>Task 3: Integrate snapping into TrimHandle and Timeline</name>
  <files>src/components/movie/timeline-trim-handle.tsx, src/components/movie/timeline.tsx</files>
  <action>
Update src/components/movie/timeline-trim-handle.tsx:
- Import findSnapTarget from @/lib/timeline-snap
- Add new props: snapTargets (SnapTarget[]), scale (number), onSnapChange (callback with SnapResult | null)
- During pointer move:
  1. Calculate the new edge frame position
  2. Call findSnapTarget with SNAP_THRESHOLD_PX = 8
  3. If snapped, adjust the delta to snap to target frame
  4. Call onSnapChange with snap result (or null if not snapping)
- On pointer up: call onSnapChange(null) to clear indicator

Update TrimHandleProps:
```typescript
interface TrimHandleProps {
  side: "left" | "right";
  onTrimDelta: (deltaFrames: number) => void;
  onTrimEnd: () => void;
  pixelsPerFrame: number;
  maxTrimFrames: number;
  currentTrimFrames: number;
  // New snap-related props
  snapTargets: SnapTarget[];
  scale: number;
  sceneStartFrame: number; // For calculating edge position
  sceneDuration: number;   // Current effective duration
  onSnapChange: (result: SnapResult | null) => void;
}
```

Update pointer move handler to integrate snapping:
```typescript
const handlePointerMove = (e: React.PointerEvent) => {
  if (!isDragging) return;
  const deltaX = e.clientX - startXRef.current;
  const rawDeltaFrames = Math.round(deltaX / pixelsPerFrame);
  const effectiveDelta = side === "left" ? rawDeltaFrames : -rawDeltaFrames;

  // Calculate what the new edge frame would be
  let newEdgeFrame: number;
  if (side === "left") {
    newEdgeFrame = sceneStartFrame + (currentTrimFrames + effectiveDelta);
  } else {
    newEdgeFrame = sceneStartFrame + sceneDuration - (currentTrimFrames + effectiveDelta);
  }

  // Check for snap
  const SNAP_THRESHOLD_PX = 8;
  const snapResult = findSnapTarget(newEdgeFrame, snapTargets, SNAP_THRESHOLD_PX, scale);

  let finalDelta = effectiveDelta;
  if (snapResult.snapped && snapResult.target) {
    // Adjust delta to land exactly on snap target
    if (side === "left") {
      finalDelta = snapResult.frame - sceneStartFrame - currentTrimFrames;
    } else {
      finalDelta = sceneStartFrame + sceneDuration - snapResult.frame - currentTrimFrames;
    }
    onSnapChange(snapResult);
  } else {
    onSnapChange(null);
  }

  // Clamp to valid range
  const clampedDelta = Math.max(
    -currentTrimFrames,
    Math.min(maxTrimFrames, finalDelta)
  );

  if (clampedDelta !== accumulatedDeltaRef.current) {
    onTrimDelta(clampedDelta - accumulatedDeltaRef.current);
    accumulatedDeltaRef.current = clampedDelta;
  }
};
```

Update src/components/movie/timeline.tsx:
- Import SnapIndicator, buildSnapTargets, calculateSceneFrameRanges from appropriate modules
- Add state for active snap: `const [activeSnap, setActiveSnap] = useState<SnapResult | null>(null)`
- Calculate scene frame ranges using calculateSceneFrameRanges
- When a scene is being trimmed:
  1. Build snap targets excluding the scene being trimmed
  2. Pass snapTargets, scale, scene frame info to TrimHandle
  3. Handle onSnapChange to update activeSnap state
- Render SnapIndicator when activeSnap is truthy
- Clear activeSnap when trim ends

Add to timeline render (after playhead, before clips):
```tsx
{/* Snap indicator */}
{activeSnap?.snapped && activeSnap.target && (
  <SnapIndicator
    frame={activeSnap.frame}
    scale={scale}
    type={activeSnap.target.type}
    visible={true}
  />
)}
```
  </action>
  <verify>
1. npm run build compiles without errors
2. Dev server: drag trim handle near another clip edge - snap indicator appears
3. Dev server: drag trim handle near playhead - snap indicator appears
4. Dev server: trim snaps to exact frame when within threshold
5. Dev server: snap indicator disappears when releasing drag
  </verify>
  <done>Snapping works during trim operations; visual indicators show snap targets</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` compiles successfully
2. Dragging trim handle near adjacent clip edge shows blue snap indicator
3. Dragging trim handle near playhead shows yellow snap indicator
4. Dragging trim handle near timeline start/end shows green snap indicator
5. Trim snaps to exact target frame when within 8px threshold
6. Snap indicator appears only during active drag
7. Snap indicator disappears immediately on pointer release
8. Trimmed position matches snap target exactly (verify in database)
</verification>

<success_criteria>
- findSnapTarget returns correct snap target within threshold
- buildSnapTargets collects all valid targets excluding edited scene
- SnapIndicator shows color-coded line at snap position
- TrimHandle integrates snap detection and adjusts delta accordingly
- Timeline manages activeSnap state and renders indicator
- Snap threshold is 8 pixels (not frames) for zoom-independent behavior
</success_criteria>

<output>
After completion, create `.planning/phases/20-timeline-interactions/20-03-SUMMARY.md`
</output>

---
phase: 14-variations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/generateAnimation.ts
autonomous: true

must_haves:
  truths:
    - "System can generate 1-4 distinct compositions in parallel from one prompt via a single Convex action"
    - "Each variation is stored with shared batchId, unique variationIndex, and variationCount"
    - "Partial failures do not lose successful variations (per-promise error handling)"
    - "Single-generation mode (variationCount=1) continues to use the existing generate action unchanged"
  artifacts:
    - path: "convex/generateAnimation.ts"
      provides: "generateVariations action + generateSingleVariation helper"
      exports: ["generate", "generateVariations", "refine", "generateContinuation"]
      contains: "generateSingleVariation"
  key_links:
    - from: "convex/generateAnimation.ts (generateVariations)"
      to: "convex/generations.ts (store)"
      via: "ctx.runMutation(internal.generations.store) with batchId, variationIndex, variationCount"
      pattern: "ctx\\.runMutation\\(internal\\.generations\\.store"
    - from: "convex/generateAnimation.ts (generateVariations)"
      to: "@anthropic-ai/sdk"
      via: "client.messages.create with temperature 0.9"
      pattern: "temperature.*0\\.9"
---

<objective>
Create the server-side `generateVariations` Convex action that generates 1-4 distinct compositions from a single prompt via parallel Claude API calls with temperature 0.9.

Purpose: This is the backend engine for the variations feature. It extracts the existing Claude call + validation + transformation logic into a reusable helper function, then orchestrates N parallel calls with shared batchId tracking and per-promise error handling.

Output: Updated `convex/generateAnimation.ts` with extracted `generateSingleVariation` helper and new `generateVariations` action export.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-variations/14-RESEARCH.md

@convex/generateAnimation.ts
@convex/generations.ts
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract generateSingleVariation helper from generate action</name>
  <files>convex/generateAnimation.ts</files>
  <action>
Extract the core Claude call + code cleaning + validation + transformation logic from the existing `generate` action handler into a plain TypeScript async helper function called `generateSingleVariation`. This function is NOT a Convex action -- it is a plain async function that can be called multiple times in parallel.

The helper function signature:
```typescript
async function generateSingleVariation(
  client: Anthropic,
  prompt: string,
  enhancedPrompt: string,
  temperature?: number,
): Promise<{ rawCode: string; code: string; durationInFrames: number; fps: number }>
```

The function should:
1. Call `client.messages.create()` with the provided `enhancedPrompt` as `system`, user `prompt` as messages, and optional `temperature` parameter (if undefined, omit it so Claude uses its default)
2. Extract text content from response (same logic as current generate action lines ~508-514)
3. Strip markdown code blocks if present (same logic as lines ~519-524)
4. Preserve rawCode before transformation
5. Extract DURATION and FPS from comments (same logic as lines ~530-538)
6. Validate with `validateRemotionCode()` (same logic as lines ~541-546)
7. Transform with `transformJSX()` (same logic as lines ~549-553)
8. Return `{ rawCode, code, durationInFrames, fps }`

Then refactor the existing `generate` action handler to call `generateSingleVariation` instead of inlining this logic. The `generate` action still handles: auth check, input validation, Anthropic client creation, settings resolution, enhanced prompt building, calling the helper (without temperature param so it uses default), and storing the result via `ctx.runMutation`. This preserves the existing behavior exactly -- no regression risk.

IMPORTANT: Do NOT change the existing `generate` action's public API (args, return type). It must continue to work identically for variationCount=1 callers. The refactoring is purely internal -- extract shared logic, then call it.

Do NOT use `ctx.runAction` to call the existing generate action from generateVariations. Per Convex best practices, use the helper function pattern instead. Actions calling actions in the same runtime have significant overhead.
  </action>
  <verify>
Run `npx convex dev --once` (or `npx convex typecheck`) to confirm the refactored code compiles without errors. The existing `generate` action must still be exported and have the same args/return type.
  </verify>
  <done>
The `generateSingleVariation` helper function exists as a plain async function in `convex/generateAnimation.ts`. The existing `generate` action handler calls this helper and behaves identically to before (same args, same return type, same storage behavior). No regression in existing functionality.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generateVariations action with parallel orchestration</name>
  <files>convex/generateAnimation.ts</files>
  <action>
Add a new exported Convex action `generateVariations` to `convex/generateAnimation.ts`. This action:

**Args:**
```typescript
args: {
  prompt: v.string(),
  variationCount: v.number(), // 1-4
  aspectRatio: v.optional(v.string()),
  durationInSeconds: v.optional(v.number()),
  fps: v.optional(v.number()),
}
```

**Handler logic:**
1. Auth check (same as generate action -- `ctx.auth.getUserIdentity()`, throw if null)
2. Input validation:
   - `args.prompt.length <= 2000` (same as generate)
   - `args.variationCount >= 1 && args.variationCount <= 4` (throw if out of range)
3. Create Anthropic client (same pattern as generate -- read `ANTHROPIC_API_KEY` from env)
4. Resolve generation settings (same as generate -- aspectRatio, dimensions, targetDuration, targetFps, targetFrames)
5. Build enhanced system prompt (same as generate -- SYSTEM_PROMPT + settings appendix)
6. Generate batchId: `crypto.randomUUID()` (works in Node.js runtime, the file already has `"use node"` directive)
7. Set `temperature = 0.9` (project decision for variation diversity)
8. Create variation promises using `Array.from({ length: args.variationCount }, (_, index) => ...)`:
   - Each promise calls `generateSingleVariation(client, args.prompt, enhancedPrompt, temperature)`
   - On success (`.then`): store via `ctx.runMutation(internal.generations.store, { ... })` with:
     - `userId: identity.tokenIdentifier`
     - `prompt: args.prompt`
     - `code: result.code`
     - `rawCode: result.rawCode`
     - `durationInFrames: result.durationInFrames`
     - `fps: targetFps` (use target, not extracted)
     - `status: "success" as const`
     - `createdAt: Date.now()` (same timestamp for all variations in batch)
     - `batchId`
     - `variationIndex: index`
     - `variationCount: args.variationCount`
     - `aspectRatio`
     - `durationInSeconds: targetDuration`
   - Return `{ id: String(id), rawCode, code, durationInFrames, fps: targetFps, variationIndex: index }`
   - On failure (`.catch`): store via `ctx.runMutation(internal.generations.store, { ... })` with:
     - Same fields but `status: "failed"`, `errorMessage: error.message`, no code/rawCode/durationInFrames/fps
   - Return `null` for failed variations
9. `const results = await Promise.all(variationPromises);`
10. Return `{ batchId, variations: results.filter(Boolean) }`

**Return type:**
```typescript
Promise<{
  batchId: string;
  variations: Array<{
    id: string;
    rawCode: string;
    code: string;
    durationInFrames: number;
    fps: number;
    variationIndex: number;
  }>;
}>
```

IMPORTANT: Use per-promise `.catch()` (not `Promise.allSettled`) so that individual failures don't lose successful results. Each failed variation is stored in the database with `status: "failed"` so it appears in the feed.

IMPORTANT: Capture `Date.now()` once before the promise array creation and use that same timestamp for all variations. This keeps them adjacent in the feed's `createdAt desc` ordering.
  </action>
  <verify>
Run `npx convex dev --once` (or `npx convex typecheck`) to confirm the new action compiles and is properly exported. Verify the action appears in the generated API types by checking that `api.generateAnimation.generateVariations` is a valid reference.
  </verify>
  <done>
The `generateVariations` action is exported from `convex/generateAnimation.ts`, accepts `{prompt, variationCount, aspectRatio?, durationInSeconds?, fps?}`, runs 1-4 parallel Claude calls with temperature 0.9, stores each result (success or failure) with shared batchId, and returns `{batchId, variations}`. Per-promise error handling ensures partial failures don't lose successful results.
  </done>
</task>

</tasks>

<verification>
1. `npx convex dev --once` completes without errors
2. Both `generate` and `generateVariations` are exported from `convex/generateAnimation.ts`
3. The existing `generate` action signature and behavior are unchanged (no regression)
4. The `generateVariations` action accepts variationCount 1-4 and produces parallel Claude calls
5. Each variation stored with batchId, variationIndex, variationCount via `internal.generations.store`
6. Per-promise `.catch()` handles individual failures without losing successful variations
</verification>

<success_criteria>
- `generate` action works exactly as before (backward compatible)
- `generateVariations` action compiles and exports correctly
- Helper function `generateSingleVariation` is used by both actions (no code duplication)
- Temperature 0.9 is used for variation calls
- `crypto.randomUUID()` generates batchId server-side
- Failed variations stored with `status: "failed"` and error message
</success_criteria>

<output>
After completion, create `.planning/phases/14-variations/14-01-SUMMARY.md`
</output>

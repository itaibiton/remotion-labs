---
phase: 14-variations
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/hooks/use-generation-settings.ts
  - src/components/generation/generation-settings.tsx
  - src/components/generation/variation-grid.tsx
  - src/components/generation/generation-feed.tsx
  - src/components/generation/generation-row.tsx
  - src/app/(app)/create/create-page-client.tsx
autonomous: true

must_haves:
  truths:
    - "User can select 1-4 variations from the settings panel before generating"
    - "Each generation row in the feed shows a grid of 1-4 variation thumbnails with V1-V4 badges when variationCount > 1"
    - "User can click a variation thumbnail to expand it full-size with preview player, code editor, and action buttons"
    - "Selected variation becomes the target for all downstream actions (save, render, continue, edit)"
    - "variationCount setting persists across sessions via localStorage"
    - "Single-generation rows (no batchId or variationCount=1) render identically to before"
  artifacts:
    - path: "src/hooks/use-generation-settings.ts"
      provides: "GenerationSettings with variationCount field"
      contains: "variationCount"
    - path: "src/components/generation/generation-settings.tsx"
      provides: "Variation count selector (1-4 button group)"
      contains: "variationCount"
    - path: "src/components/generation/variation-grid.tsx"
      provides: "Grid of 1-4 Remotion Thumbnails with V1-V4 badges and click-to-select"
      min_lines: 40
    - path: "src/components/generation/generation-feed.tsx"
      provides: "batchId grouping logic and VariationRow rendering"
      contains: "groupByBatch"
    - path: "src/app/(app)/create/create-page-client.tsx"
      provides: "generateVariations action wiring and variation selection state"
      contains: "generateVariations"
  key_links:
    - from: "src/app/(app)/create/create-page-client.tsx"
      to: "api.generateAnimation.generateVariations"
      via: "useAction hook called when settings.variationCount > 1"
      pattern: "useAction\\(api\\.generateAnimation\\.generateVariations\\)"
    - from: "src/components/generation/generation-feed.tsx"
      to: "src/components/generation/variation-grid.tsx"
      via: "VariationGrid rendered for multi-variation batches"
      pattern: "VariationGrid|variation-grid"
    - from: "src/components/generation/variation-grid.tsx"
      to: "src/app/(app)/create/create-page-client.tsx"
      via: "onSelectVariation callback propagates to handleSelectGeneration"
      pattern: "onSelectVariation|onSelect"
    - from: "src/hooks/use-generation-settings.ts"
      to: "src/components/generation/generation-settings.tsx"
      via: "GenerationSettings type with variationCount"
      pattern: "variationCount"
---

<objective>
Wire the variation UI: extend settings with variation count selector, create the variation thumbnail grid component, update the feed to group by batchId, and wire the create page to call generateVariations when count > 1 and handle variation selection.

Purpose: This is the user-facing half of the variations feature. Users need to be able to pick how many variations they want, see them as a grid in the feed, and select one to preview/edit/save.

Output: Updated settings hook and panel, new `variation-grid.tsx` component, updated feed with batch grouping, updated create page with generateVariations wiring.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-variations/14-RESEARCH.md
@.planning/phases/14-variations/14-01-SUMMARY.md

@src/hooks/use-generation-settings.ts
@src/components/generation/generation-settings.tsx
@src/components/generation/generation-feed.tsx
@src/components/generation/generation-row.tsx
@src/app/(app)/create/create-page-client.tsx
@src/lib/aspect-ratios.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend settings with variationCount and add variation count selector</name>
  <files>
    src/hooks/use-generation-settings.ts
    src/components/generation/generation-settings.tsx
  </files>
  <action>
**In `src/hooks/use-generation-settings.ts`:**

1. Add `variationCount: number` to the `GenerationSettings` interface:
```typescript
export interface GenerationSettings {
  aspectRatio: "16:9" | "1:1" | "9:16";
  durationInSeconds: number;
  fps: number;
  variationCount: number; // 1-4, default 1
}
```

2. Add `variationCount: 1` to `DEFAULT_SETTINGS`:
```typescript
export const DEFAULT_SETTINGS: GenerationSettings = {
  aspectRatio: "16:9",
  durationInSeconds: 3,
  fps: 30,
  variationCount: 1,
};
```

No other changes needed -- the existing `updateSetting` and `resetSettings` functions work generically via the `K extends keyof GenerationSettings` pattern.

**In `src/components/generation/generation-settings.tsx`:**

1. Add a "Variations" section after the FPS section (before the Reset button). Use the same button group pattern as Duration and FPS:

```typescript
const VARIATION_OPTIONS = [1, 2, 3, 4] as const;
```

2. Render a button group:
```jsx
{/* Variations */}
<div className="space-y-1.5">
  <label className="text-sm font-medium text-muted-foreground">
    Variations
  </label>
  <div className="flex gap-2">
    {VARIATION_OPTIONS.map((count) => (
      <Button
        key={count}
        variant={settings.variationCount === count ? "default" : "outline"}
        size="sm"
        onClick={() => onUpdateSetting("variationCount", count)}
      >
        {count}
      </Button>
    ))}
  </div>
</div>
```

This follows the exact same pattern as the existing Duration and FPS button groups. No new imports needed (Button is already imported).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles. Verify the settings panel renders in the browser (open create page, click Settings, confirm Variations row appears with 1-2-3-4 buttons, default=1).
  </verify>
  <done>
`GenerationSettings` type includes `variationCount: number` with default 1. Settings panel shows a Variations button group [1, 2, 3, 4] matching the style of Duration and FPS selectors. variationCount persists via localStorage like all other settings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VariationGrid component and update feed with batchId grouping</name>
  <files>
    src/components/generation/variation-grid.tsx
    src/components/generation/generation-feed.tsx
    src/components/generation/generation-row.tsx
  </files>
  <action>
**Create `src/components/generation/variation-grid.tsx`:**

A new component that renders 1-4 Remotion Thumbnails in a CSS grid with V1-V4 badges and click-to-select.

```typescript
"use client";

import { useState, useEffect } from "react";
import { Thumbnail } from "@remotion/player";
import { DynamicCode } from "@/remotion/compositions/DynamicCode";
import { ASPECT_RATIO_PRESETS, type AspectRatioKey } from "@/lib/aspect-ratios";
import { AlertCircle } from "lucide-react";
import { cn } from "@/lib/utils";
```

Props interface -- use the same generation shape as GenerationRow but accept an array:
```typescript
interface Generation {
  _id: string;
  prompt: string;
  code?: string;
  rawCode?: string;
  durationInFrames?: number;
  fps?: number;
  aspectRatio?: string;
  durationInSeconds?: number;
  status: "success" | "failed";
  errorMessage?: string;
  createdAt: number;
  batchId?: string;
  variationIndex?: number;
  variationCount?: number;
}

interface VariationGridProps {
  variations: Generation[];
  onSelectVariation: (generation: Generation) => void;
}
```

Component logic:
1. `const [isMounted, setIsMounted] = useState(false)` + useEffect to set true (same SSR guard pattern as GenerationRow)
2. Use the first variation's metadata for shared display (prompt, aspect ratio, timestamps)
3. Determine grid columns: `variations.length === 1 ? "grid-cols-1" : "grid-cols-2"`
4. Render the prompt text and metadata badges above the grid (same style as GenerationRow metadata)
5. Render the thumbnail grid:
   - Each thumbnail is a `<button>` with `onClick={() => onSelectVariation(variation)}`
   - For failed variations: show AlertCircle icon on red background (same as GenerationRow)
   - For successful variations: render `<Thumbnail>` with the variation's code
   - Overlay a V{index+1} badge: `<span className="absolute top-1 left-1 bg-black/70 text-white text-xs font-mono px-1.5 py-0.5 rounded">V{i + 1}</span>`
   - Use `relative rounded-md overflow-hidden bg-black` on the button container for badge positioning

The outer wrapper should match GenerationRow's layout: `<div className="w-full flex flex-row gap-4 p-3 rounded-lg border hover:bg-muted/50 transition-colors text-left">` with the grid on the left (constrained width) and metadata on the right. Actually, for multi-variation, use a different layout: metadata on top, grid below, to give thumbnails more space:

```jsx
<div className="w-full p-3 rounded-lg border text-left">
  {/* Metadata row */}
  <div className="flex items-start justify-between gap-4 mb-3">
    <div className="flex-1 min-w-0">
      <p className="text-sm font-medium line-clamp-2">{firstVariation.prompt}</p>
      <div className="flex items-center gap-2 flex-wrap mt-1.5">
        {/* badges: aspect ratio, duration, fps, variationCount */}
        <span className="text-xs px-1.5 py-0.5 rounded bg-muted text-muted-foreground">{aspectRatioKey}</span>
        {firstVariation.durationInSeconds && <span ...>{firstVariation.durationInSeconds}s</span>}
        <span ...>{fps}fps</span>
        <span className="text-xs px-1.5 py-0.5 rounded bg-primary/10 text-primary">{variations.length} variations</span>
      </div>
    </div>
    <p className="text-xs text-muted-foreground whitespace-nowrap">{formatRelativeTime(firstVariation.createdAt)}</p>
  </div>
  {/* Thumbnail grid */}
  <div className={`grid ${gridCols} gap-2`}>
    {/* ... thumbnails with badges ... */}
  </div>
</div>
```

Include the `formatRelativeTime` helper (copy from generation-row.tsx or extract to a shared util -- copying is fine for now, keep it simple).

Each thumbnail container should use: `style={{ aspectRatio: \`${preset.width} / ${preset.height}\` }}` to maintain proper proportions.

**Update `src/components/generation/generation-feed.tsx`:**

1. Import `VariationGrid` from `./variation-grid`
2. Add the `groupByBatch` function (from research) that groups the flat `results` array by batchId:

```typescript
interface BatchGroup {
  batchId: string | null;
  generations: Generation[];
}

function groupByBatch(generations: any[]): BatchGroup[] {
  const groups: BatchGroup[] = [];
  const batchMap = new Map<string, any[]>();

  for (const gen of generations) {
    if (gen.batchId && gen.variationCount && gen.variationCount > 1) {
      const existing = batchMap.get(gen.batchId);
      if (existing) {
        existing.push(gen);
      } else {
        const group: any[] = [gen];
        batchMap.set(gen.batchId, group);
        groups.push({ batchId: gen.batchId, generations: group });
      }
    } else {
      // Single generation or no batch: standalone row
      groups.push({ batchId: null, generations: [gen] });
    }
  }

  // Sort variations within each batch by variationIndex
  for (const group of groups) {
    group.generations.sort(
      (a: any, b: any) => (a.variationIndex ?? 0) - (b.variationIndex ?? 0)
    );
  }

  return groups;
}
```

3. In the render, use `useMemo` to compute batches: `const batches = useMemo(() => groupByBatch(results), [results]);`
4. Replace the current `results.map((generation) => <GenerationRow ...>)` with:

```jsx
{batches.map((batch) => {
  if (batch.generations.length === 1) {
    // Single generation: render as existing GenerationRow
    const gen = batch.generations[0];
    return (
      <GenerationRow
        key={gen._id}
        generation={gen}
        onSelect={onSelectGeneration}
      />
    );
  }
  // Multi-variation batch: render variation grid
  return (
    <VariationGrid
      key={batch.batchId!}
      variations={batch.generations}
      onSelectVariation={onSelectGeneration}
    />
  );
})}
```

5. Add `useMemo` to imports from React.

**Update `src/components/generation/generation-row.tsx`:**

Add `batchId`, `variationIndex`, and `variationCount` to the generation prop interface as optional fields. These are needed so the feed's groupByBatch can access them. The GenerationRow itself does not display these fields -- they are used by the parent (feed) for grouping logic:

```typescript
interface GenerationRowProps {
  generation: {
    _id: string;
    prompt: string;
    code?: string;
    rawCode?: string;
    durationInFrames?: number;
    fps?: number;
    aspectRatio?: string;
    durationInSeconds?: number;
    status: "success" | "failed";
    errorMessage?: string;
    createdAt: number;
    batchId?: string;
    variationIndex?: number;
    variationCount?: number;
  };
  onSelect: (generation: GenerationRowProps["generation"]) => void;
}
```

No rendering changes needed in GenerationRow itself.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles. Run `npm run build` (or `next build`) to confirm no build errors. Visually verify: open create page, confirm existing single-generation rows still render correctly in the feed.
  </verify>
  <done>
`VariationGrid` component renders 1-4 Remotion Thumbnails in a CSS grid with V1-V4 badges and click-to-select. The generation feed groups results by batchId, rendering single generations as GenerationRow and multi-variation batches as VariationGrid. GenerationRow's type accepts optional batch fields for grouping.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire generateVariations action into create page with selection state</name>
  <files>src/app/(app)/create/create-page-client.tsx</files>
  <action>
Update `create-page-client.tsx` to call `generateVariations` when `settings.variationCount > 1` and handle the multi-variation response.

1. **Import the new action:**
   Add `useAction` call for `generateVariations`:
   ```typescript
   const generateVariationsAction = useAction(api.generateAnimation.generateVariations);
   ```

2. **Update `handleGenerate` callback:**
   The current handleGenerate always calls `generate(...)`. Change the logic:

   ```typescript
   const handleGenerate = useCallback(async (prompt: string) => {
     // ... existing state resets (same as current) ...

     setCurrentStep("analyzing");
     await new Promise((resolve) => setTimeout(resolve, 500));
     setCurrentStep("generating");

     try {
       if (settings.variationCount > 1) {
         // Multi-variation: use generateVariations action
         const result = await generateVariationsAction({
           prompt,
           variationCount: settings.variationCount,
           aspectRatio: settings.aspectRatio,
           durationInSeconds: settings.durationInSeconds,
           fps: settings.fps,
         });

         setCurrentStep("validating");
         await new Promise((resolve) => setTimeout(resolve, 300));

         // Select first successful variation for immediate preview
         const firstSuccess = result.variations[0];
         if (firstSuccess) {
           setLastGeneration({
             id: firstSuccess.id,
             rawCode: firstSuccess.rawCode,
             code: firstSuccess.code,
             durationInFrames: firstSuccess.durationInFrames,
             fps: firstSuccess.fps,
           });
           toast.success(`Generated ${result.variations.length} variation${result.variations.length > 1 ? "s" : ""}!`);
         } else {
           throw new Error("All variations failed to generate");
         }
       } else {
         // Single generation: use existing generate action (unchanged)
         const result = await generate({
           prompt,
           aspectRatio: settings.aspectRatio,
           durationInSeconds: settings.durationInSeconds,
           fps: settings.fps,
         });

         setCurrentStep("validating");
         await new Promise((resolve) => setTimeout(resolve, 300));

         // ... existing validation and setLastGeneration logic (unchanged) ...
       }
     } catch (e) {
       // ... existing error handling (unchanged) ...
     } finally {
       setIsGenerating(false);
       setCurrentStep(null);
     }
   }, [generate, generateVariationsAction, error?.retryCount, validation, settings]);
   ```

3. **Update the `handleSelectGeneration` callback** to handle variation data:
   The existing callback already correctly maps `generation._id`, `rawCode`, `code`, etc. to `lastGeneration`. This works for both single and multi-variation selections from the feed since VariationGrid calls `onSelectVariation(generation)` with the individual generation object. No changes needed to `handleSelectGeneration` -- it already handles the right shape.

4. **Add `generateVariationsAction` to the dependency array** of `handleGenerate`.

5. **After multi-variation generation, do NOT clear lastGeneration** -- let the user see the first variation immediately as a preview. The feed will also update reactively (via `usePaginatedQuery`) and show the full variation grid for the batch.

IMPORTANT: The feed visibility logic (`!isGenerating && !lastGeneration`) means the feed is hidden when a generation is selected. This is the existing pattern and works correctly: after generating variations, the user sees the first variation's preview. They can scroll down to the feed (when they clear the selection by using "start over:" or navigating away and back) to see the full variation grid and pick a different one.

IMPORTANT: Add `settings.variationCount` to the dependency array of `handleGenerate` alongside the other settings.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles. Run `npm run build` to confirm Next.js build succeeds. Visually verify: open create page, set variations to 3 in settings, enter a prompt, confirm generation runs without errors. After generation completes, verify the first variation is shown in the preview. Clear selection and check the feed shows a variation grid for the batch.
  </verify>
  <done>
Create page calls `generateVariations` when `settings.variationCount > 1` and falls back to `generate` for count=1. Multi-variation results select the first successful variation for immediate preview. The feed's reactive query shows the full variation grid for batch selection. Variation selection propagates to all downstream actions (save, render, continue, edit) via the existing `handleSelectGeneration` callback.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no type errors)
2. `npm run build` succeeds (Next.js build)
3. Settings panel shows Variations selector [1, 2, 3, 4] with default 1
4. variationCount persists in localStorage across sessions
5. Generating with variationCount=1 uses existing `generate` action (no regression)
6. Generating with variationCount=2-4 uses `generateVariations` action
7. Feed groups results by batchId, showing VariationGrid for multi-variation batches
8. VariationGrid shows V1-V4 badges on thumbnails
9. Clicking a variation thumbnail selects it for preview/edit/save
10. Single-generation rows render identically to before
</verification>

<success_criteria>
- User can select 1-4 variations in settings panel
- System generates the requested number of variations via parallel Claude calls
- Feed shows variation grids with V1-V4 badges for multi-variation batches
- Clicking a variation expands it to full-size preview with editor and actions
- Selected variation is the target for save, render, continue, edit
- No regression: single-generation mode works exactly as before
- All TypeScript compiles, build passes
</success_criteria>

<output>
After completion, create `.planning/phases/14-variations/14-02-SUMMARY.md`
</output>

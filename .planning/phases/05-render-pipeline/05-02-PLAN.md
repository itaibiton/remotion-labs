---
phase: 05-render-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - convex/triggerRender.ts
  - convex/userQuotas.ts
autonomous: true

must_haves:
  truths:
    - "Render can be triggered from action"
    - "Progress polling updates render state"
    - "Rate limiting prevents abuse"
    - "Presigned URLs are generated for downloads"
  artifacts:
    - path: "convex/triggerRender.ts"
      provides: "Render triggering and polling actions"
      exports: ["startRender", "pollProgress"]
    - path: "convex/userQuotas.ts"
      provides: "Rate limiting for renders"
      exports: ["checkRenderQuota"]
  key_links:
    - from: "convex/triggerRender.ts"
      to: "@remotion/lambda/client"
      via: "renderMediaOnLambda call"
      pattern: "renderMediaOnLambda"
    - from: "convex/triggerRender.ts"
      to: "convex/renders.ts"
      via: "internal mutations"
      pattern: "internal\\.renders\\.(create|update)"
    - from: "convex/triggerRender.ts"
      to: "convex/userQuotas.ts"
      via: "quota check"
      pattern: "checkRenderQuota"
---

<objective>
Implement render triggering action with Remotion Lambda integration, progress polling, and rate limiting.

Purpose: This is the core render logic that calls Remotion Lambda, polls for progress, and updates render state. It connects the frontend "Render" button to actual video rendering.

Output: Convex actions for startRender (triggers Lambda render) and pollProgress (updates state), plus rate limiting via userQuotas.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-render-pipeline/05-RESEARCH.md

# Schema and renders CRUD from Plan 01
@convex/schema.ts
@convex/renders.ts
@convex/lib/renderLimits.ts

# Pattern reference for Node.js actions
@convex/generateAnimation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting with userQuotas</name>
  <files>
    convex/userQuotas.ts
  </files>
  <action>
Create convex/userQuotas.ts for render rate limiting using @convex-dev/ratelimiter.

```typescript
import { RateLimiter } from "@convex-dev/ratelimiter";
import { components } from "./_generated/api";
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { RENDER_LIMITS } from "./lib/renderLimits";

// Initialize rate limiter with the component
const rateLimiter = new RateLimiter(components.rateLimiter, {
  // 5 renders per hour per user (fixed window)
  renderLimit: {
    kind: "fixed window",
    rate: RENDER_LIMITS.RENDERS_PER_HOUR,
    period: RENDER_LIMITS.RATE_WINDOW_MS,
  },
});

/**
 * Check if user can render (and consume a token if they can)
 * Returns true if allowed, false if rate limited
 */
export const checkRenderQuota = internalMutation({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const result = await rateLimiter.limit(ctx, "renderLimit", {
      key: args.userId,
      throws: false,
    });
    return result.ok;
  },
});

/**
 * Check remaining quota without consuming
 * Used for UI feedback before render attempt
 */
export const getRemainingQuota = internalMutation({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const status = await rateLimiter.status(ctx, "renderLimit", {
      key: args.userId,
    });
    return {
      remaining: status.remaining,
      resetAt: status.resetAt,
    };
  },
});
```

Key implementation notes:
- Uses fixed window rate limiting (simpler than token bucket for this use case)
- checkRenderQuota both checks AND consumes a token (atomic operation)
- getRemainingQuota is for UI feedback only (doesn't consume)
- Both are internalMutation (called from actions only)
  </action>
  <verify>
    - `npx convex dev` runs without errors
    - No TypeScript errors in convex/userQuotas.ts
    - Internal exports visible: internal.userQuotas.checkRenderQuota
  </verify>
  <done>
    - Rate limiter configured with 5 renders/hour limit
    - checkRenderQuota mutation checks and consumes quota
    - getRemainingQuota for UI feedback
  </done>
</task>

<task type="auto">
  <name>Task 2: Create triggerRender action with startRender and pollProgress</name>
  <files>
    convex/triggerRender.ts
  </files>
  <action>
Create convex/triggerRender.ts with Node.js actions for render triggering and progress polling.

```typescript
"use node";

import { action, internalAction } from "./_generated/server";
import { v } from "convex/values";
import {
  renderMediaOnLambda,
  getRenderProgress,
  presignUrl,
} from "@remotion/lambda/client";
import { internal } from "./_generated/api";
import { RENDER_LIMITS } from "./lib/renderLimits";

/**
 * Start a render job on Remotion Lambda
 * Checks quota, triggers render, stores job, and schedules polling
 */
export const startRender = action({
  args: {
    generationId: v.id("generations"),
    animationProps: v.object({
      text: v.string(),
      style: v.union(
        v.literal("fade-in"),
        v.literal("typewriter"),
        v.literal("slide-up"),
        v.literal("scale")
      ),
      fontFamily: v.string(),
      fontSize: v.number(),
      color: v.string(),
      backgroundColor: v.optional(v.string()),
      durationInFrames: v.number(),
      fps: v.literal(30),
    }),
  },
  handler: async (ctx, args) => {
    // Verify authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Must be authenticated to render");
    }

    // Check rate limit
    const quotaOk = await ctx.runMutation(internal.userQuotas.checkRenderQuota, {
      userId: identity.tokenIdentifier,
    });
    if (!quotaOk) {
      throw new Error("Render quota exceeded. You can render up to 5 videos per hour. Please try again later.");
    }

    // Validate duration cap
    if (args.animationProps.durationInFrames > RENDER_LIMITS.MAX_DURATION_FRAMES) {
      throw new Error(`Animation too long. Maximum duration is ${RENDER_LIMITS.MAX_DURATION_SECONDS} seconds.`);
    }

    // Get environment variables
    const functionName = process.env.REMOTION_LAMBDA_FUNCTION_NAME;
    const serveUrl = process.env.REMOTION_SERVE_URL;
    const region = (process.env.REMOTION_AWS_REGION || "us-east-1") as "us-east-1";

    if (!functionName || !serveUrl) {
      throw new Error("Render service not configured. Please contact support.");
    }

    // Trigger Lambda render
    const { renderId, bucketName } = await renderMediaOnLambda({
      region,
      functionName,
      serveUrl,
      composition: "TextAnimation",
      inputProps: args.animationProps,
      codec: "h264",
      timeoutInMilliseconds: RENDER_LIMITS.LAMBDA_TIMEOUT_MS,
    });

    // Store render job in database
    const renderJobId = await ctx.runMutation(internal.renders.create, {
      userId: identity.tokenIdentifier,
      generationId: args.generationId,
      renderId,
      bucketName,
      status: "rendering",
      progress: 0,
    });

    // Schedule first progress poll
    await ctx.scheduler.runAfter(
      RENDER_LIMITS.POLL_INTERVAL_MS,
      internal.triggerRender.pollProgress,
      {
        renderJobId,
        renderId,
        bucketName,
        region,
      }
    );

    return { renderJobId, renderId };
  },
});

/**
 * Poll render progress from Remotion Lambda
 * Updates database and schedules next poll if not complete
 */
export const pollProgress = internalAction({
  args: {
    renderJobId: v.id("renders"),
    renderId: v.string(),
    bucketName: v.string(),
    region: v.string(),
  },
  handler: async (ctx, args) => {
    const functionName = process.env.REMOTION_LAMBDA_FUNCTION_NAME;
    if (!functionName) {
      await ctx.runMutation(internal.renders.update, {
        id: args.renderJobId,
        status: "failed",
        error: "Render service not configured",
      });
      return;
    }

    try {
      const progress = await getRenderProgress({
        renderId: args.renderId,
        bucketName: args.bucketName,
        functionName,
        region: args.region as "us-east-1",
      });

      // Check for fatal error
      if (progress.fatalErrorEncountered) {
        await ctx.runMutation(internal.renders.update, {
          id: args.renderJobId,
          status: "failed",
          error: progress.errors?.[0]?.message ?? "Render failed",
          completedAt: Date.now(),
        });
        return;
      }

      // Check if complete
      if (progress.done && progress.outputFile) {
        // Generate presigned URL for download (1 hour expiry)
        const outputUrl = await presignUrl({
          region: args.region as "us-east-1",
          bucketName: args.bucketName,
          objectKey: progress.outKey!,
          expiresInSeconds: 3600,
          checkIfObjectExists: true,
        });

        await ctx.runMutation(internal.renders.update, {
          id: args.renderJobId,
          status: "complete",
          progress: 100,
          outputUrl,
          outputSize: progress.outputSizeInBytes ?? undefined,
          completedAt: Date.now(),
        });
        return;
      }

      // Update progress and schedule next poll
      const progressPercent = Math.round((progress.overallProgress ?? 0) * 100);
      await ctx.runMutation(internal.renders.update, {
        id: args.renderJobId,
        progress: progressPercent,
      });

      // Schedule next poll
      await ctx.scheduler.runAfter(
        RENDER_LIMITS.POLL_INTERVAL_MS,
        internal.triggerRender.pollProgress,
        {
          renderJobId: args.renderJobId,
          renderId: args.renderId,
          bucketName: args.bucketName,
          region: args.region,
        }
      );
    } catch (error) {
      // Handle polling errors
      await ctx.runMutation(internal.renders.update, {
        id: args.renderJobId,
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error during render",
        completedAt: Date.now(),
      });
    }
  },
});

/**
 * Regenerate presigned URL for download
 * Used when original URL expires
 */
export const refreshDownloadUrl = action({
  args: { renderJobId: v.id("renders") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Must be authenticated");
    }

    // Get the render job
    const render = await ctx.runQuery(internal.renders.getInternal, {
      id: args.renderJobId,
    });

    if (!render || render.userId !== identity.tokenIdentifier) {
      throw new Error("Render not found");
    }

    if (render.status !== "complete") {
      throw new Error("Render not complete");
    }

    // We need the outKey, but we only stored outputUrl
    // For now, return existing URL if still valid
    // TODO: Store outKey in renders table for refresh capability
    return { outputUrl: render.outputUrl };
  },
});
```

Important implementation notes:
- Uses `@remotion/lambda/client` (light client for serverless)
- REMOTION_AWS_* env vars are used by the Lambda client automatically
- startRender is public action (called from UI)
- pollProgress is internalAction (called by scheduler only)
- Scheduler pattern: self-rescheduling until complete/failed
- Presigned URLs expire after 1 hour; refreshDownloadUrl for re-generation
  </action>
  <verify>
    - `npx convex dev` runs without errors
    - Exports visible: api.triggerRender.startRender, api.triggerRender.refreshDownloadUrl
    - Internal: internal.triggerRender.pollProgress
    - No TypeScript errors
  </verify>
  <done>
    - startRender action triggers Lambda render
    - pollProgress action updates state via scheduler
    - Rate limiting integrated
    - Presigned URL generation works
  </done>
</task>

<task type="auto">
  <name>Task 3: Add internal query for render lookup</name>
  <files>
    convex/renders.ts
  </files>
  <action>
Add an internal query to renders.ts that can be called from actions for authorization checks:

Add this to the existing convex/renders.ts file:

```typescript
// Add this import if not present
import { internalQuery } from "./_generated/server";

// Add this internal query for action use
export const getInternal = internalQuery({
  args: { id: v.id("renders") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});
```

This allows the refreshDownloadUrl action to look up render records for authorization.
  </action>
  <verify>
    - `npx convex dev` runs without errors
    - internal.renders.getInternal accessible from triggerRender.ts
  </verify>
  <done>
    - getInternal query added for action lookups
    - refreshDownloadUrl can verify ownership
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx convex dev` runs without errors
2. No TypeScript errors in convex/ directory
3. api.triggerRender.startRender is callable
4. Rate limiting is wired correctly
5. Scheduler is set up for polling
</verification>

<success_criteria>
- startRender action triggers Remotion Lambda render
- pollProgress action polls and updates render state
- Rate limiting prevents more than 5 renders/hour/user
- Presigned URLs generated for completed renders
- Self-rescheduling polling until render completes or fails
</success_criteria>

<output>
After completion, create `.planning/phases/05-render-pipeline/05-02-SUMMARY.md`
</output>

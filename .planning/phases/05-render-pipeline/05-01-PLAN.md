---
phase: 05-render-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/renders.ts
  - convex/lib/renderLimits.ts
  - convex/convex.config.ts
  - package.json
autonomous: true
user_setup:
  - service: aws
    why: "Remotion Lambda requires AWS credentials for Lambda invocation"
    env_vars:
      - name: REMOTION_AWS_ACCESS_KEY_ID
        source: "AWS IAM -> Users -> Create user -> Access keys"
      - name: REMOTION_AWS_SECRET_ACCESS_KEY
        source: "AWS IAM -> Users -> Create user -> Access keys"
      - name: REMOTION_LAMBDA_FUNCTION_NAME
        source: "After running: npx remotion lambda functions create"
      - name: REMOTION_SERVE_URL
        source: "After running: npx remotion lambda sites create"
    dashboard_config:
      - task: "Create IAM user with Lambda + S3 permissions"
        location: "AWS Console -> IAM -> Users"
      - task: "Deploy Remotion Lambda function"
        location: "Terminal: npx remotion lambda functions create"
      - task: "Deploy Remotion site to S3"
        location: "Terminal: npx remotion lambda sites create src/remotion/index.ts"

must_haves:
  truths:
    - "Renders table exists with correct schema"
    - "Rate limiter is configured with 5 renders/hour limit"
    - "CRUD operations for renders work correctly"
  artifacts:
    - path: "convex/schema.ts"
      provides: "renders table definition"
      contains: "renders: defineTable"
    - path: "convex/renders.ts"
      provides: "Render CRUD mutations/queries"
      exports: ["create", "update", "get", "getByGeneration"]
    - path: "convex/lib/renderLimits.ts"
      provides: "Render limit constants"
      exports: ["RENDER_LIMITS"]
    - path: "convex/convex.config.ts"
      provides: "Rate limiter component registration"
      contains: "rateLimiter"
  key_links:
    - from: "convex/renders.ts"
      to: "convex/schema.ts"
      via: "table reference"
      pattern: "ctx\\.db\\.(insert|get|patch)"
---

<objective>
Set up backend foundation for render pipeline: database schema, rate limiting, and basic CRUD operations.

Purpose: Create the data layer that will store render jobs, track progress, and enforce per-user quotas. This foundation enables the render action and UI components in subsequent plans.

Output: Convex schema with renders table, rate limiter configuration, render mutations/queries, and installed dependencies.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-render-pipeline/05-RESEARCH.md

# Existing schema to extend
@convex/schema.ts

# Pattern reference for Convex actions
@convex/generateAnimation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure rate limiter</name>
  <files>
    package.json
    convex/convex.config.ts
    convex/lib/renderLimits.ts
  </files>
  <action>
1. Install required packages:
   ```bash
   npm install @remotion/lambda @convex-dev/ratelimiter
   ```

2. Create convex/convex.config.ts to register the rate limiter component:
   ```typescript
   import { defineApp } from "convex/server";
   import rateLimiter from "@convex-dev/ratelimiter/convex.config";

   const app = defineApp();
   app.use(rateLimiter);

   export default app;
   ```

3. Create convex/lib/renderLimits.ts with render limit constants:
   ```typescript
   // Render limits for abuse prevention
   export const RENDER_LIMITS = {
     // Rate limiting
     RENDERS_PER_HOUR: 5,
     RATE_WINDOW_MS: 60 * 60 * 1000, // 1 hour

     // Quality caps
     MAX_RESOLUTION_WIDTH: 1920,
     MAX_RESOLUTION_HEIGHT: 1080,
     MAX_DURATION_SECONDS: 20,
     MAX_DURATION_FRAMES: 20 * 30, // 600 frames at 30fps

     // Timeouts
     LAMBDA_TIMEOUT_MS: 60000, // 1 minute
     POLL_INTERVAL_MS: 2000, // 2 seconds
   } as const;
   ```

Note: Use @remotion/lambda (not @remotion/lambda/client) in package.json - the /client path is for imports only.
  </action>
  <verify>
    - `npm ls @remotion/lambda` shows installed
    - `npm ls @convex-dev/ratelimiter` shows installed
    - Files exist: convex/convex.config.ts, convex/lib/renderLimits.ts
    - `npx convex dev` starts without config errors
  </verify>
  <done>
    - @remotion/lambda and @convex-dev/ratelimiter installed
    - Rate limiter component registered in convex.config.ts
    - Render limits constants defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Add renders table to schema</name>
  <files>
    convex/schema.ts
  </files>
  <action>
Add renders table to existing schema.ts. Keep all existing tables (users, generations).

Add this table definition after generations:

```typescript
renders: defineTable({
  userId: v.string(),
  generationId: v.id("generations"),
  renderId: v.string(),           // Remotion Lambda render ID
  bucketName: v.string(),         // S3 bucket
  status: v.union(
    v.literal("pending"),
    v.literal("rendering"),
    v.literal("complete"),
    v.literal("failed")
  ),
  progress: v.number(),           // 0-100
  outputUrl: v.optional(v.string()),  // Presigned download URL
  outputSize: v.optional(v.number()), // Bytes
  error: v.optional(v.string()),
  createdAt: v.number(),
  completedAt: v.optional(v.number()),
})
  .index("by_user", ["userId"])
  .index("by_generation", ["generationId"])
  .index("by_status", ["status"]),
```

Ensure:
- userId is string (matches tokenIdentifier pattern from users table)
- generationId references generations table
- status uses union of literals (not string)
- Three indexes for common query patterns
  </action>
  <verify>
    - `npx convex dev` runs without schema errors
    - Schema shows renders table in Convex dashboard
  </verify>
  <done>
    - convex/schema.ts includes renders table with all fields
    - Indexes by_user, by_generation, by_status defined
  </done>
</task>

<task type="auto">
  <name>Task 3: Create renders CRUD mutations and queries</name>
  <files>
    convex/renders.ts
  </files>
  <action>
Create convex/renders.ts with mutations and queries for render management.

```typescript
import { v } from "convex/values";
import { mutation, query, internalMutation } from "./_generated/server";

// Internal mutation for creating render records (called from action)
export const create = internalMutation({
  args: {
    userId: v.string(),
    generationId: v.id("generations"),
    renderId: v.string(),
    bucketName: v.string(),
    status: v.union(
      v.literal("pending"),
      v.literal("rendering")
    ),
    progress: v.number(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("renders", {
      ...args,
      createdAt: Date.now(),
    });
  },
});

// Internal mutation for updating render state (called from action)
export const update = internalMutation({
  args: {
    id: v.id("renders"),
    status: v.optional(v.union(
      v.literal("pending"),
      v.literal("rendering"),
      v.literal("complete"),
      v.literal("failed")
    )),
    progress: v.optional(v.number()),
    outputUrl: v.optional(v.string()),
    outputSize: v.optional(v.number()),
    error: v.optional(v.string()),
    completedAt: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    // Filter out undefined values
    const cleanUpdates = Object.fromEntries(
      Object.entries(updates).filter(([_, v]) => v !== undefined)
    );
    await ctx.db.patch(id, cleanUpdates);
  },
});

// Public query for getting render by ID (for progress UI)
export const get = query({
  args: { id: v.id("renders") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

// Public query for getting render by generation (to check if render exists)
export const getByGeneration = query({
  args: { generationId: v.id("generations") },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("renders")
      .withIndex("by_generation", (q) => q.eq("generationId", args.generationId))
      .order("desc")
      .first();
  },
});

// Public query for user's render history
export const listByUser = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    return await ctx.db
      .query("renders")
      .withIndex("by_user", (q) => q.eq("userId", identity.tokenIdentifier))
      .order("desc")
      .take(20);
  },
});
```

Key design decisions:
- create and update are internalMutation (called from actions only)
- get, getByGeneration, listByUser are public queries (for reactive UI)
- getByGeneration returns most recent render for a generation
- listByUser requires authentication
  </action>
  <verify>
    - `npx convex dev` runs without errors
    - Exports visible in convex/_generated/api.ts: renders.get, renders.getByGeneration, renders.listByUser
    - Internal exports: internal.renders.create, internal.renders.update
  </verify>
  <done>
    - convex/renders.ts exports create, update, get, getByGeneration, listByUser
    - Internal mutations for action use
    - Public queries for reactive UI subscriptions
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm ls @remotion/lambda @convex-dev/ratelimiter` shows both installed
2. `npx convex dev` runs without errors
3. Convex dashboard shows renders table with correct schema
4. No TypeScript errors in convex/ directory
</verification>

<success_criteria>
- renders table exists in Convex schema
- Rate limiter component registered
- Render limit constants defined
- CRUD operations for renders implemented
- All internal mutations accessible via internal.renders.*
- All public queries accessible via api.renders.*
</success_criteria>

<output>
After completion, create `.planning/phases/05-render-pipeline/05-01-SUMMARY.md`
</output>

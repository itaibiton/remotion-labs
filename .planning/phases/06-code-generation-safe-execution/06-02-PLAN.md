---
phase: 06-code-generation-safe-execution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/code-executor.ts
  - src/remotion/compositions/DynamicCode.tsx
autonomous: true

must_haves:
  truths:
    - "Code executor runs validated JSX in isolated scope without access to globals"
    - "DynamicCode composition renders AI-generated code at runtime"
    - "Execution timeout prevents infinite loops (5 second limit)"
  artifacts:
    - path: "src/lib/code-executor.ts"
      provides: "Safe code execution via Function constructor with scope injection"
      exports: ["executeCode", "ExecutionResult", "RemotionScope"]
    - path: "src/remotion/compositions/DynamicCode.tsx"
      provides: "Meta-composition that executes dynamic code"
      exports: ["DynamicCode", "DynamicCodeProps"]
  key_links:
    - from: "src/remotion/compositions/DynamicCode.tsx"
      to: "src/lib/code-executor.ts"
      via: "imports executeCode for runtime"
      pattern: "import.*executeCode.*from.*code-executor"
---

<objective>
Build code execution system: Function constructor with controlled scope injection and DynamicCode meta-composition for Remotion.

Purpose: Execute validated AI-generated code safely. The executor provides only Remotion APIs via scope injection - no access to browser globals, DOM, or network.
Output: Code executor module and DynamicCode composition that renders AI code at runtime.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-code-generation-safe-execution/06-CONTEXT.md
@src/remotion/compositions/TextAnimation.tsx
@src/lib/remotion-allowlist.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create code executor with scope injection</name>
  <files>src/lib/code-executor.ts</files>
  <action>
    Create src/lib/code-executor.ts that:

    1. Defines RemotionScope - all Remotion APIs available to generated code:
       ```typescript
       const RemotionScope = {
         // React
         React,
         useState: React.useState,
         useEffect: React.useEffect,
         useMemo: React.useMemo,
         useCallback: React.useCallback,

         // Remotion core
         AbsoluteFill,
         useCurrentFrame,
         useVideoConfig,
         interpolate,
         spring,
         Sequence,
         Easing,
         random,

         // Remotion media
         Audio,
         Img,
         staticFile,
         OffthreadVideo,
         Video,

         // Remotion composition helpers
         Composition,
         Still,
         Series,
         Loop,
         Freeze,
       };
       ```

    2. Implements executeCode function:
       - Takes transformed JS code (from sucrase output)
       - Uses Function constructor with scope parameter names
       - Wraps execution in try/catch
       - Returns ExecutionResult with the component or error

    3. Implementation pattern:
       ```typescript
       export function executeCode(code: string): ExecutionResult {
         try {
           // Build function with scope parameters
           const scopeKeys = Object.keys(RemotionScope);
           const scopeValues = Object.values(RemotionScope);

           // The code should export default a component
           // Wrap it to capture the export
           const wrappedCode = `
             ${code}
             return typeof MyComposition !== 'undefined' ? MyComposition : null;
           `;

           const fn = new Function(...scopeKeys, wrappedCode);
           const Component = fn(...scopeValues);

           if (!Component) {
             return { success: false, error: "Code must export a component named MyComposition" };
           }

           return { success: true, Component };
         } catch (e) {
           return { success: false, error: e.message };
         }
       }
       ```

    4. Handle common patterns:
       - Code exports: "const MyComposition = () => ..." or "function MyComposition() { ... }"
       - The generated code should define MyComposition (our prompt will specify this)

    Security notes:
    - Function constructor ONLY has access to what we pass in scope
    - No window, document, fetch, eval, require, import in scope
    - Code runs in strict mode implicitly
  </action>
  <verify>
    - npm run build passes
    - File exports executeCode, ExecutionResult, RemotionScope
  </verify>
  <done>
    executeCode with valid Remotion code returns { success: true, Component }
    executeCode with invalid code returns { success: false, error: "..." }
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicCode meta-composition</name>
  <files>src/remotion/compositions/DynamicCode.tsx</files>
  <action>
    Create src/remotion/compositions/DynamicCode.tsx that:

    1. Receives generated code as prop (inputProps from Lambda):
       ```typescript
       export interface DynamicCodeProps {
         code: string;           // Validated, transformed JS code
         durationInFrames: number;
         fps: number;
         width?: number;
         height?: number;
       }
       ```

    2. Executes code using executeCode from code-executor
    3. Renders the resulting component or error fallback
    4. Memoizes execution to avoid re-running on every frame

    Implementation:
    ```typescript
    export const DynamicCode: React.FC<DynamicCodeProps> = ({
      code,
      durationInFrames,
      fps,
    }) => {
      const result = useMemo(() => executeCode(code), [code]);

      if (!result.success) {
        return (
          <AbsoluteFill style={{ backgroundColor: "#1a1a1a", color: "#ef4444" }}>
            <div style={{ padding: 40 }}>
              <h2>Execution Error</h2>
              <pre>{result.error}</pre>
            </div>
          </AbsoluteFill>
        );
      }

      const Component = result.Component;
      return <Component />;
    };
    ```

    5. Export for both Player (preview) and Lambda (render):
       - This composition will be used by PreviewPlayer for browser preview
       - This composition will be deployed with Lambda bundle for rendering

    Why this pattern:
    - Code as inputProps means Lambda doesn't need to re-bundle for each generation
    - Same composition works for preview and render
    - Execution is sandboxed identically in both environments
  </action>
  <verify>
    - npm run build passes
    - File exports DynamicCode and DynamicCodeProps
  </verify>
  <done>
    DynamicCode composition can be imported and used with Remotion Player
    DynamicCode renders generated component or shows error state
  </done>
</task>

<task type="auto">
  <name>Task 3: Add execution timeout protection</name>
  <files>src/lib/code-executor.ts</files>
  <action>
    Update src/lib/code-executor.ts to add timeout protection:

    1. Since we can't easily timeout synchronous code in JS, add loop detection in AST validation (done in Plan 01's validator)

    2. For this task, add runtime protection:
       - Wrap execution in a frame counter that throws if too many iterations
       - This handles the case where code has deeply nested but finite loops

    3. Add frame-based execution limit:
       ```typescript
       // In RemotionScope, add a frame counter
       let frameCount = 0;
       const MAX_FRAMES = 10000;

       const checkFrame = () => {
         frameCount++;
         if (frameCount > MAX_FRAMES) {
           throw new Error("Execution limit exceeded");
         }
       };

       // Add to scope so generated code can use interpolate safely
       const safeInterpolate = (...args) => {
         checkFrame();
         return interpolate(...args);
       };
       ```

    4. Document the execution limits in code comments:
       - Max iterations: 10000 operations
       - If exceeded, show "Execution limit exceeded" error

    Note: True async timeout isn't possible with Function constructor.
    The AST validator (Plan 01) should catch obvious infinite loops (while(true)).
    This runtime check catches edge cases that pass validation.
  </action>
  <verify>
    - npm run build passes
    - ExecutionResult type includes error for timeout case
  </verify>
  <done>
    Code with excessive iterations returns { success: false, error: "Execution limit exceeded" }
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. `npm run lint` passes (or has only pre-existing warnings)
3. Both files exist with correct exports:
   - src/lib/code-executor.ts
   - src/remotion/compositions/DynamicCode.tsx
4. DynamicCode can render a simple hardcoded test component
</verification>

<success_criteria>
- Code executor safely runs transformed JS with Remotion scope only
- DynamicCode composition renders generated components
- Execution errors show user-friendly error state
- Timeout protection prevents infinite loops
- Ready for integration with generation pipeline (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-generation-safe-execution/06-02-SUMMARY.md`
</output>

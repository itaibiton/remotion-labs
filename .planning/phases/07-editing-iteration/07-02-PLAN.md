---
phase: 07-editing-iteration
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/hooks/use-debounced-validation.ts
  - src/components/code-editor/code-display.tsx
autonomous: true

must_haves:
  truths:
    - "User can toggle editor from read-only to editable mode"
    - "Code is validated ~500ms after user stops typing"
    - "Validation errors appear as red squiggles in the editor with hover tooltips"
    - "Status badge shows green check (valid) or red X (errors)"
    - "User can reset editor to last AI-generated code"
  artifacts:
    - path: "src/hooks/use-debounced-validation.ts"
      provides: "Debounced validation hook with isValid, errors, transformedCode"
      exports: ["useDebouncedValidation"]
    - path: "src/components/code-editor/code-display.tsx"
      provides: "Editable Monaco editor with toggle, status badge, reset button, inline markers"
      exports: ["CodeDisplay"]
  key_links:
    - from: "src/hooks/use-debounced-validation.ts"
      to: "src/lib/code-validator.ts"
      via: "imports validateRemotionCode"
      pattern: "validateRemotionCode"
    - from: "src/hooks/use-debounced-validation.ts"
      to: "src/lib/code-transformer.ts"
      via: "imports transformJSX"
      pattern: "transformJSX"
    - from: "src/components/code-editor/code-display.tsx"
      to: "src/hooks/use-debounced-validation.ts"
      via: "uses useDebouncedValidation hook"
      pattern: "useDebouncedValidation"
---

<objective>
Make the Monaco editor editable with live debounced validation and inline error markers.

Purpose: Users need to edit generated code directly. Every edit must be validated before the preview updates. Errors must be shown inline with specific suggestions, and a status badge communicates whether the current code is valid.

Output: Editable code editor with toggle, debounced validation hook, inline Monaco error markers, status badge, and reset-to-original button.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-editing-iteration/07-CONTEXT.md
@.planning/phases/07-editing-iteration/07-RESEARCH.md
@.planning/phases/07-editing-iteration/07-01-SUMMARY.md
@src/components/code-editor/code-display.tsx
@src/lib/code-validator.ts
@src/lib/code-transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create debounced validation hook</name>
  <files>src/hooks/use-debounced-validation.ts</files>
  <action>
Create a new file `src/hooks/use-debounced-validation.ts` that provides the core validation pipeline for user-edited code.

```typescript
import { useState, useEffect, useCallback, useRef } from "react";
import { validateRemotionCode } from "@/lib/code-validator";
import { transformJSX } from "@/lib/code-transformer";
```

The hook signature:
```typescript
export interface ValidationError {
  line: number;
  column: number;
  message: string;
  suggestion?: string;
}

export interface ValidationState {
  isValid: boolean;
  errors: ValidationError[];
  transformedCode: string | null;
}

export function useDebouncedValidation(
  code: string,
  delay?: number,        // default 500
  skipValidation?: boolean  // default false -- skip for AI-generated code updates
): ValidationState
```

Implementation:
1. Use `useState` for the validation state (isValid, errors, transformedCode).
2. Use `useEffect` with a `setTimeout` for debouncing. The effect depends on `code`, `delay`, and `skipValidation`.
3. When `skipValidation` is true, return early without scheduling validation. This is used when AI-generated code is applied (already validated server-side).
4. Inside the timeout callback:
   a. Call `validateRemotionCode(code)` from `@/lib/code-validator`
   b. If validation fails, set errors and isValid=false, transformedCode=null. Map errors to include the suggestion field.
   c. If validation passes, call `transformJSX(code)` from `@/lib/code-transformer`
   d. If transform fails, set a single error with the transform error message
   e. If transform succeeds, set isValid=true, errors=[], transformedCode=result
5. Clean up the timeout on unmount and re-render (return `() => clearTimeout(timer)`).

Also export a `resetValidation` callback via the hook return that lets callers force the state to a known-good state (used when AI generates new code):
```typescript
return { ...state, resetToValid };
```
Where `resetToValid` is a `useCallback` that sets `{ isValid: true, errors: [], transformedCode: null }`.

Important: The delay default should be 500 (ms) per CONTEXT.md decision.
  </action>
  <verify>Run `npm run build` to verify TypeScript compilation. Check that the file exports `useDebouncedValidation`, `ValidationError`, and `ValidationState`.</verify>
  <done>Hook validates code on debounced schedule, returns isValid/errors/transformedCode, supports skipValidation flag for AI code updates.</done>
</task>

<task type="auto">
  <name>Task 2: Make CodeDisplay editable with edit toggle, status badge, and markers</name>
  <files>src/components/code-editor/code-display.tsx</files>
  <action>
Substantially rework `code-display.tsx` to support editing mode. The current component is read-only with a copy button. It needs:

1. **New props interface:**
```typescript
export interface CodeDisplayProps {
  code: string;                    // Current code (raw JSX)
  originalCode?: string;           // AI-generated code for "Reset to original"
  isEditing: boolean;              // Whether editor is in edit mode
  onEditToggle: () => void;        // Toggle edit mode callback
  onChange?: (code: string) => void; // Code change callback (when editing)
  errors?: ValidationError[];      // Validation errors from parent
  isValid?: boolean;               // Validation status from parent
}
```
Import `ValidationError` from `@/hooks/use-debounced-validation`.

2. **Editor state:**
   - Store refs for Monaco instance and editor instance (`useRef<Monaco>`, `useRef<editor.IStandaloneCodeEditor>`)
   - The `onMount` callback stores both refs

3. **Error markers effect:**
   Use a `useEffect` that watches `errors` prop. When errors change:
   - Get the Monaco instance and model from refs
   - If no errors: call `monaco.editor.setModelMarkers(model, "validation", [])` to CLEAR markers
   - If errors: map each error to `IMarkerData` with `severity: MonacoMarkerSeverity.Error`, line/column from error, and `message` set to the error's suggestion (if available) or message. Set `endColumn` to `column + 20` for reasonable highlight width.
   - Call `monaco.editor.setModelMarkers(model, "validation", markers)`

4. **Header with status badge, edit toggle, reset, and copy buttons:**
   Replace the current header. New layout:
   ```
   [Status Badge] Generated Code    [Reset to Original] [Edit/Lock] [Copy]
   ```
   - Status badge: green `CheckCircle` icon when `isValid !== false`, red `XCircle` icon when `isValid === false`. Use lucide-react icons.
   - "Edit" button: shows `Pencil` icon when not editing, `Lock` icon when editing. Calls `onEditToggle`.
   - "Reset to Original" button: only visible when `isEditing && originalCode && code !== originalCode`. Calls `onChange?.(originalCode)`. Shows `RotateCcw` icon.
   - Copy button: keep existing functionality.

5. **Monaco Editor options:**
   - Change `readOnly` from hardcoded `true` to `!isEditing`
   - Change height from "300px" to "400px" (more room for editing)
   - Add `onChange` handler that calls `props.onChange?.(value ?? "")`
   - When editing is enabled: set `renderLineHighlight: "line"` (was "none"), `cursorBlinking: "blink"` (was "solid")
   - When read-only: keep current settings

6. **Import icons from lucide-react:** Add `CheckCircle`, `XCircle`, `Pencil`, `Lock`, `RotateCcw` alongside existing `Copy`, `Check`.

Keep the existing copy-to-clipboard functionality. The component should work in both read-only mode (backwards compatible) and edit mode.
  </action>
  <verify>Run `npm run build` to verify TypeScript compilation. Check that CodeDisplay accepts the new props. Verify the file imports from `@/hooks/use-debounced-validation` and lucide-react.</verify>
  <done>CodeDisplay supports edit mode toggle, shows status badge (green/red), displays inline error markers via Monaco, has reset-to-original button, and height increased to 400px for editing.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `useDebouncedValidation` hook exists and exports correctly
3. `CodeDisplay` component accepts `isEditing`, `onEditToggle`, `onChange`, `errors`, `isValid`, `originalCode` props
4. Monaco markers are set/cleared based on errors prop
5. Status badge renders different icons based on isValid
</verification>

<success_criteria>
- Editor toggles between read-only and editable mode via Edit button
- Validation runs ~500ms after typing stops (debounced)
- Errors show as red squiggles with hover tooltips containing suggestions
- Status badge shows green checkmark (valid) or red X (errors)
- Reset to Original button reverts to AI-generated code
- All new components build without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-editing-iteration/07-02-SUMMARY.md`
</output>

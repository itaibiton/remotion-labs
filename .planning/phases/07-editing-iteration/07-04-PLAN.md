---
phase: 07-editing-iteration
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - src/components/generation/prompt-input.tsx
  - src/app/create/create-page-client.tsx
autonomous: false

must_haves:
  truths:
    - "User can edit code in editor and see preview update after validation"
    - "User can type a refinement message and see code update from Claude"
    - "Chat history is visible below the prompt area"
    - "Unified input acts as generation when no code exists, refinement when code exists"
    - "Typing 'start over: [prompt]' clears everything and generates fresh"
    - "Preview freezes on last valid code when editor has errors"
  artifacts:
    - path: "src/components/generation/prompt-input.tsx"
      provides: "Unified input field switching between generate and refine modes"
      contains: "start over"
    - path: "src/app/create/create-page-client.tsx"
      provides: "Full create page with editing, chat refinement, and validation wiring"
      contains: "useDebouncedValidation"
  key_links:
    - from: "src/app/create/create-page-client.tsx"
      to: "src/hooks/use-debounced-validation.ts"
      via: "uses useDebouncedValidation hook for live editor validation"
      pattern: "useDebouncedValidation"
    - from: "src/app/create/create-page-client.tsx"
      to: "convex/generateAnimation.ts (refine)"
      via: "useAction(api.generateAnimation.refine)"
      pattern: "api\\.generateAnimation\\.refine"
    - from: "src/app/create/create-page-client.tsx"
      to: "src/components/generation/chat-messages.tsx"
      via: "renders ChatMessages with conversation state"
      pattern: "ChatMessages"
    - from: "src/app/create/create-page-client.tsx"
      to: "src/components/code-editor/code-display.tsx"
      via: "passes editing props (isEditing, onChange, errors, isValid)"
      pattern: "isEditing.*onChange.*errors"
    - from: "src/components/generation/prompt-input.tsx"
      to: "create-page-client.tsx"
      via: "onSubmit callback handles generate vs refine"
      pattern: "onSubmit"
---

<objective>
Wire the full editing and chat refinement flow into the create page with a unified input field.

Purpose: This is the integration plan -- connecting the editable editor (Plan 02), chat refinement action (Plan 03), and existing generation flow into a cohesive user experience. The unified input field switches between generation and refinement based on context.

Output: Fully functional create page where users can generate, edit, refine via chat, and see live-validated previews. Unified input field adapts to context.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-editing-iteration/07-CONTEXT.md
@.planning/phases/07-editing-iteration/07-RESEARCH.md
@.planning/phases/07-editing-iteration/07-02-SUMMARY.md
@.planning/phases/07-editing-iteration/07-03-SUMMARY.md
@src/app/create/create-page-client.tsx
@src/components/generation/prompt-input.tsx
@src/components/code-editor/code-display.tsx
@src/hooks/use-debounced-validation.ts
@src/components/generation/chat-messages.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update PromptInput for unified input (generate vs refine)</name>
  <files>src/components/generation/prompt-input.tsx</files>
  <action>
Modify `prompt-input.tsx` to support two modes: generation (no existing code) and refinement (code exists).

1. **Update props interface:**
```typescript
interface PromptInputProps {
  onSubmit: (prompt: string) => Promise<void>;
  isGenerating: boolean;
  isRefining?: boolean;      // NEW: refinement in progress
  hasExistingCode?: boolean; // NEW: whether code exists (switches mode)
  disabled?: boolean;
  placeholder?: string;
}
```

2. **Context-aware behavior:**
   - When `hasExistingCode` is false (or undefined): behave exactly as today -- generation mode. Show example prompts. Button says "Generate Animation". Placeholder: "Describe the animation you want to create..."
   - When `hasExistingCode` is true: refinement mode. Hide example prompts. Button says "Send" (shorter for chat feel). Placeholder: "Describe changes (e.g., 'make it faster', 'change color to blue')..." Show a small hint below input: "Type 'start over: [prompt]' to regenerate from scratch"

3. **Update button/loading state:**
   - When `isRefining` is true: button shows "Refining..." and is disabled
   - When `isGenerating` is true: button shows "Generating..." and is disabled (existing behavior)
   - isDisabled should also consider `isRefining`

4. **Keep existing functionality intact:** Character count, max chars, example prompts (in generation mode only), submit logic. The parent component will handle the "start over:" detection -- the PromptInput just passes the raw text through.

5. **Layout adjustment for refinement mode:** In refinement mode, reduce the textarea min-height to `min-h-[80px]` (from 120px) since refinement messages are typically shorter. Keep 120px for generation mode.

6. **Clear input after submit:** Add `setPrompt("")` after `await onSubmit(trimmedPrompt)` succeeds. This makes chat feel more natural -- input clears after sending. Wrap in try/catch so the input only clears on success.
  </action>
  <verify>Run `npm run build` to verify TypeScript compilation. Check that PromptInput accepts the new props. Verify the file still renders example prompts when `hasExistingCode` is false.</verify>
  <done>PromptInput adapts between generation and refinement modes. Shows appropriate placeholder, button text, and example prompts based on context. Input clears after successful submit.</done>
</task>

<task type="auto">
  <name>Task 2: Wire editing, chat, and validation into create page</name>
  <files>src/app/create/create-page-client.tsx</files>
  <action>
This is the main integration task. Rework `create-page-client.tsx` to support code editing, chat refinement, and live validation.

1. **New imports:**
```typescript
import { useDebouncedValidation } from "@/hooks/use-debounced-validation";
import { ChatMessages, type ChatMessage } from "@/components/generation/chat-messages";
```
Update the existing `useAction` import to also get the refine action:
```typescript
const refine = useAction(api.generateAnimation.refine);
```

2. **New state in CreateContent:**
```typescript
// Editing state
const [isEditing, setIsEditing] = useState(false);
const [editorCode, setEditorCode] = useState<string>(""); // Raw JSX in editor
const [originalCode, setOriginalCode] = useState<string>(""); // Last AI-generated code
const [skipValidation, setSkipValidation] = useState(false);

// Chat state
const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
const [isRefining, setIsRefining] = useState(false);
```

3. **Use the debounced validation hook:**
```typescript
const validation = useDebouncedValidation(editorCode, 500, skipValidation);
```

4. **Determine the preview code:** The preview should use:
   - If validation has transformedCode (user edit validated): use `validation.transformedCode`
   - Otherwise: use `lastGeneration.code` (the transformed code from server)
   This ensures preview freezes on last valid code when validation fails (per CONTEXT.md).

5. **Update handleGenerate callback:**
   After successful generation, update new state:
   ```typescript
   // Use rawCode for editor display, code for preview
   setEditorCode(result.rawCode ?? result.code);
   setOriginalCode(result.rawCode ?? result.code);
   setSkipValidation(true); // Skip debounced validation for AI code
   // Reset chat on new generation
   setChatMessages([]);
   setIsEditing(false);
   // After a tick, re-enable validation for future edits
   setTimeout(() => setSkipValidation(false), 100);
   ```
   Also update the GenerationResult interface to include `rawCode`:
   ```typescript
   interface GenerationResult {
     id: string;
     rawCode?: string;  // Original JSX for editor
     code: string;       // Transformed JS for preview
     durationInFrames: number;
     fps: number;
   }
   ```
   And populate `rawCode` from the generate action result.

6. **Add handleRefine callback:**
```typescript
const handleRefine = useCallback(
  async (prompt: string) => {
    setIsRefining(true);
    try {
      // Add user message to chat
      const userMessage: ChatMessage = { role: "user", content: prompt };
      setChatMessages((prev) => [...prev, userMessage]);

      const result = await refine({
        currentCode: editorCode,
        refinementPrompt: prompt,
        conversationHistory: chatMessages.map((m) => ({
          role: m.role,
          content: m.content,
        })),
      });

      // Update editor with refined code
      setEditorCode(result.rawCode);
      setOriginalCode(result.rawCode);
      setSkipValidation(true);
      setTimeout(() => setSkipValidation(false), 100);

      // Update generation result for preview
      setLastGeneration((prev) =>
        prev
          ? {
              ...prev,
              rawCode: result.rawCode,
              code: result.code,
              durationInFrames: result.durationInFrames,
              fps: result.fps,
            }
          : prev
      );

      // Add assistant message to chat (short summary, not full code)
      const assistantMessage: ChatMessage = {
        role: "assistant",
        content: `Updated the animation based on: "${prompt}"`,
      };
      setChatMessages((prev) => [...prev, assistantMessage]);

      toast.success("Animation refined!");
    } catch (e) {
      const errorMessage = e instanceof Error ? e.message : "Refinement failed";
      toast.error(errorMessage);
      // Remove the user message on failure
      setChatMessages((prev) => prev.slice(0, -1));
    } finally {
      setIsRefining(false);
    }
  },
  [editorCode, chatMessages, refine]
);
```

7. **Add handleUnifiedSubmit callback:**
   This replaces direct handleGenerate usage from the PromptInput. It decides whether to generate or refine:
```typescript
const handleUnifiedSubmit = useCallback(
  async (text: string) => {
    if (!lastGeneration) {
      // No existing code: fresh generation
      await handleGenerate(text);
    } else if (text.toLowerCase().startsWith("start over:")) {
      // Explicit regeneration: clear everything
      const newPrompt = text.replace(/^start over:\s*/i, "").trim();
      setChatMessages([]);
      setEditorCode("");
      setOriginalCode("");
      setLastGeneration(null);
      setIsEditing(false);
      if (newPrompt) {
        await handleGenerate(newPrompt);
      }
    } else {
      // Refinement: send to Claude with current code + history
      await handleRefine(text);
    }
  },
  [lastGeneration, handleGenerate, handleRefine]
);
```

8. **Add handleEditorChange callback:**
```typescript
const handleEditorChange = useCallback((newCode: string) => {
  setEditorCode(newCode);
  setSkipValidation(false); // Enable validation for manual edits
}, []);
```

9. **Add handleEditToggle callback:**
```typescript
const handleEditToggle = useCallback(() => {
  setIsEditing((prev) => !prev);
}, []);
```

10. **Update the JSX layout for the success state.** The current layout is:
    - Two-column grid: Preview | Code
    - Render section below
    - PromptInput at bottom

    New layout when code exists:
    ```
    [Two-column grid: Preview | Code Editor]
    [Chat Messages (if any)]
    [PromptInput (unified mode)]
    [Render section]
    ```

    Specifically:
    - **Preview:** Use the computed preview code (validCode or lastGeneration.code). Pass `durationInFrames` and `fps` from lastGeneration.
    - **CodeDisplay:** Pass new props:
      ```
      code={editorCode}
      originalCode={originalCode}
      isEditing={isEditing}
      onEditToggle={handleEditToggle}
      onChange={handleEditorChange}
      errors={validation.errors}
      isValid={validation.isValid}
      ```
    - **ChatMessages:** Render below the grid, above the prompt input, only when `chatMessages.length > 0`:
      ```
      <ChatMessages messages={chatMessages} isRefining={isRefining} />
      ```
    - **PromptInput:** Use `handleUnifiedSubmit` as onSubmit. Pass new props:
      ```
      hasExistingCode={!!lastGeneration}
      isRefining={isRefining}
      ```

    Move the PromptInput to always show below the results (currently it's hidden during generation, which is fine to keep). The key change is it should also appear when `lastGeneration` exists, not just when there's no generation.

11. **Fix PromptInput visibility:** Currently the PromptInput only shows when `!isGenerating`. Update: show it when `!isGenerating && !isRefining` (hide during both generation and refinement). Also show it when there IS a lastGeneration (it currently shows regardless, which is correct).

12. **Remove the "Regenerate" link** from the render section since the unified input with "start over:" replaces it. Or keep it as a convenience button that calls `handleGenerate(lastPrompt)`.
  </action>
  <verify>Run `npm run build` to verify TypeScript compilation. Verify that create-page-client.tsx imports from `@/hooks/use-debounced-validation` and `@/components/generation/chat-messages`. Verify it calls `useAction(api.generateAnimation.refine)`. Verify the PromptInput receives `hasExistingCode` and `isRefining` props.</verify>
  <done>Create page supports full editing flow: generate -> edit in editor -> refine via chat -> preview updates on valid code. Unified input field adapts to context. Chat history visible. Preview freezes on last valid code.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete editing and chat refinement flow: editable Monaco editor with live validation, chat refinement via Claude, unified input field, status badge, inline error markers, and reset-to-original button.</what-built>
  <how-to-verify>
1. Open http://localhost:3000/create (ensure dev server is running)
2. Generate an animation with any prompt (e.g., "bouncing ball animation")
3. Verify the Monaco editor shows generated code and is read-only by default
4. Click the "Edit" button -- editor should become editable (cursor changes, highlight appears)
5. Make a valid edit (e.g., change a color value) -- wait ~500ms, preview should update
6. Make an invalid edit (e.g., type "fetch('http://example.com')") -- red squiggles should appear, status badge should turn red, preview should freeze on last valid code
7. Hover over the red squiggles -- tooltip should show an actionable suggestion
8. Click "Reset to Original" -- editor should revert to AI-generated code, errors should clear
9. In the prompt input (now in refinement mode), type "make it faster and change the background to blue" and submit
10. Wait for Claude's response -- editor should update with new code, chat message should appear
11. Verify chat shows both user message and assistant summary
12. Type "start over: spinning cube" -- everything should reset and generate fresh
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. PromptInput shows generation mode when no code exists, refinement mode when code exists
3. Create page wires validation hook, chat state, and editor editing together
4. Preview uses validation.transformedCode when available, otherwise lastGeneration.code
5. Chat messages appear between editor and prompt input
6. "start over:" prefix triggers full reset and fresh generation
7. Human verifies the full flow works end-to-end
</verification>

<success_criteria>
- User can generate, then edit code in the editor with live preview updates
- User can refine via chat and see the code update automatically
- Unified input switches between generation and refinement modes
- "start over:" triggers fresh generation with full reset
- Validation errors show inline in editor with actionable suggestions
- Preview freezes on last valid code when editor has errors
- Chat history is visible and auto-scrolls
- All interactions verified by human testing
</success_criteria>

<output>
After completion, create `.planning/phases/07-editing-iteration/07-04-SUMMARY.md`
</output>

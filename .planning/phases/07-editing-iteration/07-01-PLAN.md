---
phase: 07-editing-iteration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/generateAnimation.ts
  - convex/schema.ts
  - convex/generations.ts
  - src/lib/code-validator.ts
autonomous: true

must_haves:
  truths:
    - "Generation returns original JSX alongside transformed code"
    - "Validation errors contain actionable fix suggestions referencing Remotion APIs"
    - "Schema supports storing raw JSX for editor display"
  artifacts:
    - path: "convex/generateAnimation.ts"
      provides: "Generate action returning rawCode and code"
      contains: "rawCode"
    - path: "convex/schema.ts"
      provides: "rawCode field on generations table"
      contains: "rawCode"
    - path: "convex/generations.ts"
      provides: "Store mutation accepting rawCode"
      contains: "rawCode"
    - path: "src/lib/code-validator.ts"
      provides: "Actionable error messages with Remotion-specific suggestions"
      contains: "suggestion"
  key_links:
    - from: "convex/generateAnimation.ts"
      to: "convex/generations.ts"
      via: "internal.generations.store with rawCode field"
      pattern: "rawCode"
    - from: "src/lib/code-validator.ts"
      to: "src/lib/remotion-allowlist.ts"
      via: "imports BLOCKED_PATTERNS for suggestion mapping"
      pattern: "BLOCKED_PATTERNS"
---

<objective>
Extend the generation pipeline to return original JSX alongside transformed code, and enhance the validator to produce actionable error suggestions.

Purpose: The editor currently displays transformed JS (React.createElement calls). For editing to work, users need to see original JSX. The validator currently returns generic "unsafe patterns" messages that are useless for fixing code. Both must be addressed before editing features can be built.

Output: Generation action returns both rawCode (original JSX) and code (transformed JS). Schema stores rawCode. Validator returns line-specific suggestions referencing Remotion APIs.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-editing-iteration/07-CONTEXT.md
@.planning/phases/07-editing-iteration/07-RESEARCH.md
@convex/generateAnimation.ts
@convex/schema.ts
@convex/generations.ts
@src/lib/code-validator.ts
@src/lib/remotion-allowlist.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Return raw JSX from generation and update schema</name>
  <files>convex/schema.ts, convex/generations.ts, convex/generateAnimation.ts</files>
  <action>
1. In `convex/schema.ts`: Add `rawCode: v.optional(v.string())` field to the `generations` table, right after the existing `code` field. This stores the original JSX as Claude wrote it (before sucrase transformation). Keep it optional for backwards compatibility with existing data.

2. In `convex/generations.ts`: Add `rawCode: v.optional(v.string())` to the store mutation args, matching the schema update.

3. In `convex/generateAnimation.ts`, modify the `generate` action handler:
   - After extracting and cleaning the code from Claude's response (the `code` variable around line 378), save it as `rawCode` before transformation. Specifically, after the markdown stripping and before validation, add: `const rawCode = code;`
   - In the `ctx.runMutation(internal.generations.store, {...})` call, add `rawCode` to the stored fields
   - Update the return type and return statement to include `rawCode`:
     ```
     return {
       id: generationId,
       rawCode,           // Original JSX for editor display
       code: transformed.code,  // Transformed JS for execution
       durationInFrames,
       fps,
     };
     ```

Important: The `code` field continues to hold transformed JS (for preview execution). The new `rawCode` field holds the original JSX (for editor display). Both are needed.
  </action>
  <verify>Run `npx convex dev --once` from the project root to verify schema sync. Run `npm run build` to verify TypeScript compilation. Grep the generateAnimation.ts file for "rawCode" to confirm it appears in the return type, the mutation call, and as a local variable.</verify>
  <done>Generation action returns `{ id, rawCode, code, durationInFrames, fps }`. Schema has `rawCode` field. Store mutation accepts rawCode.</done>
</task>

<task type="auto">
  <name>Task 2: Add actionable error suggestions to code validator</name>
  <files>src/lib/code-validator.ts</files>
  <action>
Enhance `validateRemotionCode` in `src/lib/code-validator.ts` to return actionable suggestions alongside generic security messages. This is for the editor's inline error display -- users need to know WHAT to fix, not just that something is wrong.

1. Add a `suggestion` field to the error type in `ValidationResult`:
   ```typescript
   export interface ValidationResult {
     valid: boolean;
     errors: Array<{
       line: number;
       column: number;
       message: string;
       suggestion?: string;  // NEW: Actionable fix suggestion
     }>;
   }
   ```

2. Create a suggestion mapping function after the existing `addError` function:
   ```typescript
   function getSuggestionForBlockedPattern(identifier: string): string | undefined {
     const suggestions: Record<string, string> = {
       fetch: "Network requests are not available. Use interpolate() or spring() for data-driven animations.",
       XMLHttpRequest: "Network requests are not available. Use interpolate() or spring() for data-driven animations.",
       WebSocket: "Network requests are not available. Use interpolate() for animations.",
       setTimeout: "'setTimeout' is not available. Use <Sequence from={frameNumber}> for timed animations.",
       setInterval: "'setInterval' is not available. Use useCurrentFrame() for frame-based animation loops.",
       document: "DOM access is not available. Use <AbsoluteFill> and inline styles for layout.",
       window: "Browser globals are not available. Use useVideoConfig() for width, height, fps.",
       navigator: "Browser globals are not available. Use useVideoConfig() for dimensions.",
       process: "Node.js globals are not available in the Remotion sandbox.",
       eval: "Dynamic code execution is not allowed. Write your logic directly.",
       Function: "The Function constructor is not allowed. Define functions with arrow syntax or function declarations.",
       require: "Use the pre-injected APIs instead of require(). All Remotion and React APIs are already available.",
       import: "Import statements are not needed. All APIs (AbsoluteFill, interpolate, spring, etc.) are pre-injected.",
       localStorage: "Browser storage is not available. Use React state (useState) instead.",
       sessionStorage: "Browser storage is not available. Use React state (useState) instead.",
       Proxy: "Proxy is not available in the sandbox.",
       constructor: "Direct constructor access is not allowed. Use standard object creation patterns.",
       prototype: "Prototype manipulation is not allowed.",
     };
     return suggestions[identifier];
   }
   ```

3. Update the `addError` helper to accept an optional `identifier` parameter and look up suggestions:
   ```typescript
   function addError(
     errors: ValidationResult["errors"],
     node: ASTNode,
     message: string,
     identifier?: string
   ): void {
     errors.push({
       line: node.loc?.start?.line ?? 1,
       column: node.loc?.start?.column ?? 0,
       message,
       suggestion: identifier ? getSuggestionForBlockedPattern(identifier) : undefined,
     });
   }
   ```

4. Update all callers of `addError` in the validation functions to pass the relevant identifier:
   - `validateIdentifier`: pass `node.name` as identifier
   - `validateCallExpression`: pass `callee.name` as identifier (for require/eval/Function)
   - `validateMemberExpression`: pass `objectName` as identifier
   - `validateNewExpression`: pass `callee.name` as identifier
   - `validateImport`: pass `"import"` as identifier
   - `ImportExpression` case: pass `"import"` as identifier

5. Add a special case for syntax errors. Update the catch block in `validateRemotionCode` to include a suggestion:
   ```typescript
   return {
     valid: false,
     errors: [{
       line: parseError.loc?.line ?? 1,
       column: parseError.loc?.column ?? 0,
       message: "Code contains syntax errors",
       suggestion: "Check for missing brackets, quotes, or semicolons near this line.",
     }],
   };
   ```

Do NOT change the `CodeDisplayError` interface in `code-display.tsx` -- that will be updated in Plan 02 when the editor is made editable.
  </action>
  <verify>Run `npm run build` to verify TypeScript compilation. The existing ValidationResult interface should now include the optional `suggestion` field. Grep for "getSuggestionForBlockedPattern" to confirm the function exists. Grep for "suggestion" in code-validator.ts to confirm it's wired through addError.</verify>
  <done>Validator returns errors with actionable `suggestion` field. Each blocked pattern has a Remotion-specific fix suggestion. Syntax errors include helpful guidance.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `npx convex dev --once` succeeds (schema sync)
3. `convex/generateAnimation.ts` returns `rawCode` in generate action
4. `src/lib/code-validator.ts` exports `ValidationResult` with `suggestion` field
5. All blocked patterns have corresponding suggestions
</verification>

<success_criteria>
- Generation action returns both `rawCode` (original JSX) and `code` (transformed JS)
- Schema stores `rawCode` for editor display in Phase 7 editing
- Validator errors include actionable suggestions referencing specific Remotion APIs
- All existing functionality continues to work (backwards compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/07-editing-iteration/07-01-SUMMARY.md`
</output>

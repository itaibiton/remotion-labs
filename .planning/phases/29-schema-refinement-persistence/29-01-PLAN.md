---
phase: 29-schema-refinement-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/generations.ts
autonomous: true

must_haves:
  truths:
    - "Generations table has parentGenerationId field (optional self-reference)"
    - "Generations table has refinementPrompt field (optional string)"
    - "Generations table has by_parent index for efficient child lookups"
    - "createPending mutation accepts parentGenerationId and refinementPrompt args"
    - "listByParent query uses proper index (no type assertion hack)"
    - "getRefinementChain query returns ordered version history"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Updated generations schema with refinement fields"
      contains: "parentGenerationId"
    - path: "convex/generations.ts"
      provides: "Updated mutations and new queries"
      exports: ["createPending", "store", "listByParent", "getRefinementChain", "getInternal"]
  key_links:
    - from: "convex/generations.ts"
      to: "convex/schema.ts"
      via: "schema field definitions"
      pattern: "parentGenerationId.*v\\.optional\\(v\\.id\\(\"generations\"\\)\\)"
    - from: "listByParent"
      to: "by_parent index"
      via: "withIndex call"
      pattern: "\\.withIndex\\(\"by_parent\""
---

<objective>
Add schema fields and queries for refinement persistence

Purpose: Enable refinements to be stored as linked generations in the database, creating a parent-child relationship chain that supports version history tracking.

Output: Updated schema with parentGenerationId and refinementPrompt fields, by_parent index, updated mutations, fixed listByParent query, new getRefinementChain query, and getInternal internal query for action use.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-schema-refinement-persistence/29-RESEARCH.md
@convex/schema.ts
@convex/generations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parentGenerationId and refinementPrompt fields to schema</name>
  <files>convex/schema.ts</files>
  <action>
Add two new optional fields to the generations table definition:

1. `parentGenerationId: v.optional(v.id("generations"))` - Self-reference for refinement chain
2. `refinementPrompt: v.optional(v.string())` - The instruction used to create this refinement

Add these after the existing `continuationType` field (around line 47).

Add a new index:
```typescript
.index("by_parent", ["parentGenerationId"])
```

Add this after the existing `.index("by_status_created", ["status", "createdAt"])` line.

IMPORTANT: Do NOT modify any other schema definitions (users, clips, movies, renders tables).
  </action>
  <verify>
Run `npx convex dev --once` to validate schema compiles. Check output for schema changes being applied.
  </verify>
  <done>
Schema has parentGenerationId and refinementPrompt fields in generations table, and by_parent index is defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update createPending and store mutations to accept new fields</name>
  <files>convex/generations.ts</files>
  <action>
Update the `createPending` internalMutation:

1. Add new args:
   - `parentGenerationId: v.optional(v.id("generations"))`
   - `refinementPrompt: v.optional(v.string())`

2. Add these fields to the `ctx.db.insert` call in the handler.

Update the `store` internalMutation the same way:
1. Add the same two optional args
2. Add them to the `ctx.db.insert` call

Follow the existing pattern - look at how `continuationType` is handled as a model (optional arg, included in insert).
  </action>
  <verify>
Run `npx convex dev --once` to validate mutations compile. TypeScript should show no errors.
  </verify>
  <done>
createPending and store mutations accept parentGenerationId and refinementPrompt arguments and insert them into the database.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add getRefinementChain query, fix listByParent, add getInternal</name>
  <files>convex/generations.ts</files>
  <action>
**1. Fix listByParent query (around line 294-317):**

Replace the current filter-based implementation with index-based lookup:
```typescript
export const listByParent = query({
  args: {
    parentId: v.id("generations"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Must be logged in to view variations");
    }

    // Use proper index now that schema field exists
    const generations = await ctx.db
      .query("generations")
      .withIndex("by_parent", (q) => q.eq("parentGenerationId", args.parentId))
      .order("asc")  // Oldest refinement first (chronological)
      .collect();

    return generations;
  },
});
```

Remove the `as any` type assertion hack and the "Phase 27" comments.

**2. Add getRefinementChain query:**

Add new query after listByParent:
```typescript
/**
 * Get the full refinement chain for a generation.
 * Returns ordered array from original (V1) to current generation.
 * Walks up the parent chain, then reverses for chronological order.
 */
export const getRefinementChain = query({
  args: {
    generationId: v.id("generations"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Must be logged in to view refinement chain");
    }

    // Walk up the parent chain to find all ancestors
    const ancestors: Array<typeof generation> = [];
    let currentId: Id<"generations"> | undefined = args.generationId;
    const seen = new Set<string>();  // Cycle detection

    for (let i = 0; i < 50 && currentId; i++) {
      if (seen.has(currentId)) break;  // Cycle detected
      seen.add(currentId);

      const gen = await ctx.db.get(currentId);
      if (!gen) break;

      ancestors.push(gen);
      currentId = gen.parentGenerationId;
    }

    // Reverse to get chronological order: original -> V1 -> V2 -> current
    return ancestors.reverse();
  },
});
```

Note: TypeScript will infer the type from `ctx.db.get`. Use `Doc<"generations">` if needed from `import { Doc } from "./_generated/dataModel"`.

**3. Add getInternal internal query:**

Add before the public `get` query (around line 231):
```typescript
import { internalQuery } from "./_generated/server";

// ... existing code ...

/**
 * Internal query to get a generation by ID without auth check.
 * Used by actions that need to read generation data.
 */
export const getInternal = internalQuery({
  args: {
    id: v.id("generations"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});
```

Make sure to add `internalQuery` to the imports at the top of the file.
  </action>
  <verify>
Run `npx convex dev --once` to validate all queries compile. Test in Convex dashboard:
1. listByParent should work without errors
2. getRefinementChain should return array (empty for generations without parents)
  </verify>
  <done>
- listByParent uses withIndex("by_parent") instead of filter with type assertion
- getRefinementChain query exists and returns ordered chain array
- getInternal internal query exists for action use
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. Schema validation:
   ```bash
   npx convex dev --once
   ```
   Should show schema changes applied without errors.

2. TypeScript check:
   ```bash
   npx tsc --noEmit
   ```
   Should pass with no errors in convex/ directory.

3. Query functionality (manual check in Convex dashboard):
   - listByParent query exists and accepts parentId arg
   - getRefinementChain query exists and accepts generationId arg
   - getInternal internal query exists
</verification>

<success_criteria>
- [ ] convex/schema.ts has parentGenerationId field (v.optional(v.id("generations")))
- [ ] convex/schema.ts has refinementPrompt field (v.optional(v.string()))
- [ ] convex/schema.ts has .index("by_parent", ["parentGenerationId"])
- [ ] createPending mutation accepts and inserts parentGenerationId and refinementPrompt
- [ ] store mutation accepts and inserts parentGenerationId and refinementPrompt
- [ ] listByParent uses .withIndex("by_parent") (no type assertion)
- [ ] getRefinementChain query returns ordered array of generations
- [ ] getInternal internal query exists
- [ ] `npx convex dev --once` succeeds
- [ ] `npx tsc --noEmit` passes
</success_criteria>

<output>
After completion, create `.planning/phases/29-schema-refinement-persistence/29-01-SUMMARY.md`
</output>

---
phase: 29-schema-refinement-persistence
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - convex/generateAnimation.ts
  - src/components/creation/creation-fullscreen-modal.tsx
autonomous: true

must_haves:
  truths:
    - "Submitting a refinement creates a new generation document in the database"
    - "New generation has parentGenerationId pointing to the original generation"
    - "New generation has refinementPrompt storing the instruction used"
    - "UI calls refineAndPersist instead of refine for save-to-database flow"
  artifacts:
    - path: "convex/generateAnimation.ts"
      provides: "refineAndPersist action for persisted refinements"
      exports: ["refineAndPersist"]
    - path: "src/components/creation/creation-fullscreen-modal.tsx"
      provides: "Updated refinement handler calling refineAndPersist"
      contains: "refineAndPersist"
  key_links:
    - from: "convex/generateAnimation.ts:refineAndPersist"
      to: "internal.generations.createPending"
      via: "ctx.runMutation call"
      pattern: "internal\\.generations\\.createPending"
    - from: "convex/generateAnimation.ts:refineAndPersist"
      to: "internal.generations.getInternal"
      via: "ctx.runQuery call"
      pattern: "internal\\.generations\\.getInternal"
    - from: "src/components/creation/creation-fullscreen-modal.tsx"
      to: "api.generateAnimation.refineAndPersist"
      via: "useAction hook"
      pattern: "api\\.generateAnimation\\.refineAndPersist"
---

<objective>
Create refineAndPersist action and wire UI to use it

Purpose: Enable refinements to be persisted to the database by creating a new action that follows the pending-then-complete pattern (like generatePrequel), and update the UI to call this action when the user submits a refinement.

Output: New refineAndPersist action that creates a child generation linked to parent, and updated UI that calls this action and navigates to the new generation.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-schema-refinement-persistence/29-RESEARCH.md
@.planning/phases/29-schema-refinement-persistence/29-01-SUMMARY.md
@convex/generateAnimation.ts
@src/components/creation/creation-fullscreen-modal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create refineAndPersist action</name>
  <files>convex/generateAnimation.ts</files>
  <action>
Add a new `refineAndPersist` action after the existing `refine` action (around line 1102). This action:

1. Takes args:
   - `parentGenerationId: v.id("generations")` - The generation being refined
   - `refinementPrompt: v.string()` - The refinement instruction
   - `conversationHistory: v.array(...)` - Same as existing refine action

2. Returns the same shape as other generation actions:
   - `id: Id<"generations">` - The new child generation ID
   - `rawCode: string`
   - `code: string`
   - `durationInFrames: number`
   - `fps: number`

3. Follows the generatePrequel pattern:
   a. Check authentication
   b. Get parent generation via `ctx.runQuery(internal.generations.getInternal, { id: args.parentGenerationId })`
   c. Validate parent exists and has rawCode
   d. Create pending child via `ctx.runMutation(internal.generations.createPending, {...})` with:
      - userId from identity
      - prompt from parent.prompt (keep original prompt)
      - createdAt from Date.now()
      - aspectRatio, durationInSeconds from parent
      - parentGenerationId: args.parentGenerationId (NEW)
      - refinementPrompt: args.refinementPrompt (NEW)
   e. Try: Call Claude API (reuse REFINEMENT_SYSTEM_PROMPT and similar logic to existing refine action)
   f. On success: Patch via `internal.generations.complete` with success status
   g. On error: Patch via `internal.generations.complete` with failed status, then throw

Implementation:

```typescript
/**
 * Refine existing Remotion animation code and persist as new generation.
 * Creates a child generation linked to the parent via parentGenerationId.
 * Unlike `refine` (which returns without persisting), this saves to database.
 */
export const refineAndPersist = action({
  args: {
    parentGenerationId: v.id("generations"),
    refinementPrompt: v.string(),
    conversationHistory: v.array(
      v.object({
        role: v.union(v.literal("user"), v.literal("assistant")),
        content: v.string(),
      })
    ),
  },
  handler: async (ctx, args): Promise<{
    id: Id<"generations">;
    rawCode: string;
    code: string;
    durationInFrames: number;
    fps: number;
  }> => {
    // Check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("You must be logged in to refine animations");
    }

    // Get parent generation
    const parent = await ctx.runQuery(internal.generations.getInternal, {
      id: args.parentGenerationId,
    });
    if (!parent) {
      throw new Error("Parent generation not found");
    }
    if (!parent.rawCode) {
      throw new Error("Parent generation has no code to refine");
    }

    // Create Anthropic client
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error("ANTHROPIC_API_KEY not configured.");
    }

    const client = new Anthropic({ apiKey });

    // Create pending child generation with link to parent
    const createdAt = Date.now();
    const childId = await ctx.runMutation(internal.generations.createPending, {
      userId: identity.tokenIdentifier,
      prompt: parent.prompt,  // Keep original prompt
      createdAt,
      aspectRatio: parent.aspectRatio,
      durationInSeconds: parent.durationInSeconds,
      parentGenerationId: args.parentGenerationId,
      refinementPrompt: args.refinementPrompt,
    });

    try {
      // Build messages array (same as existing refine action)
      const maxHistoryMessages = 20;
      const trimmedHistory = args.conversationHistory.slice(-maxHistoryMessages);

      const messages: Array<{ role: "user" | "assistant"; content: string }> = [
        ...trimmedHistory,
        {
          role: "user" as const,
          content: `Current Remotion code:\n\n${parent.rawCode}\n\nPlease modify it: ${args.refinementPrompt}`,
        },
      ];

      // Call Claude API with retry
      const response = await withRetry((model) =>
        client.messages.create({
          model,
          max_tokens: 4096,
          system: REFINEMENT_SYSTEM_PROMPT,
          messages,
        })
      );

      // Extract text content
      const textContent = response.content.find((block) => block.type === "text");
      if (!textContent || textContent.type !== "text") {
        throw new Error("Failed to refine animation: No response from AI.");
      }

      // Clean code
      let rawCode = textContent.text.trim();
      if (rawCode.startsWith("```")) {
        rawCode = rawCode
          .replace(/^```(?:jsx|tsx|javascript|typescript)?\s*\n?/, "")
          .replace(/\n?```\s*$/, "")
          .trim();
      }

      // Extract metadata
      const durationMatch = rawCode.match(/\/\/\s*DURATION:\s*(\d+)/);
      const fpsMatch = rawCode.match(/\/\/\s*FPS:\s*(\d+)/);
      const rawDuration = durationMatch ? parseInt(durationMatch[1]) : 90;
      const durationInFrames = Math.min(Math.max(rawDuration, 30), 600);
      const fps = fpsMatch ? Math.min(Math.max(parseInt(fpsMatch[1]), 15), 60) : 30;

      // Validate the refined code
      const validation = validateRemotionCode(rawCode);
      if (!validation.valid) {
        throw new Error(
          `Refined code validation failed: ${validation.errors[0]?.message || "Invalid code"}`
        );
      }

      // Transform JSX to JavaScript
      const transformed = transformJSX(rawCode);
      if (!transformed.success || !transformed.code) {
        throw new Error(transformed.error || "Code transformation failed");
      }

      // Patch pending -> success
      await ctx.runMutation(internal.generations.complete, {
        id: childId,
        status: "success" as const,
        code: transformed.code,
        rawCode,
        durationInFrames,
        fps,
      });

      return {
        id: childId,
        rawCode,
        code: transformed.code,
        durationInFrames,
        fps,
      };
    } catch (e) {
      // Patch pending -> failed
      const errorMessage = e instanceof Error ? e.message : "Refinement failed";
      await ctx.runMutation(internal.generations.complete, {
        id: childId,
        status: "failed" as const,
        errorMessage,
      });
      throw e;
    }
  },
});
```

IMPORTANT: The action uses internal functions that already exist (internal.generations.createPending, internal.generations.complete, internal.generations.getInternal from Plan 01). The helper functions (withRetry, validateRemotionCode, transformJSX, REFINEMENT_SYSTEM_PROMPT) are already defined in the file.
  </action>
  <verify>
Run `npx convex dev --once` to validate action compiles. Check that `api.generateAnimation.refineAndPersist` is available.
  </verify>
  <done>
refineAndPersist action exists and:
- Accepts parentGenerationId, refinementPrompt, conversationHistory
- Creates pending generation with parentGenerationId and refinementPrompt
- Calls Claude API with refinement prompt
- Patches to success/failed
- Returns { id, rawCode, code, durationInFrames, fps }
  </done>
</task>

<task type="auto">
  <name>Task 2: Update UI to call refineAndPersist and navigate to new generation</name>
  <files>src/components/creation/creation-fullscreen-modal.tsx</files>
  <action>
Update the CreationFullscreenModal component to use refineAndPersist instead of refine:

1. Add new action hook:
   ```typescript
   const refineAndPersistAction = useAction(api.generateAnimation.refineAndPersist);
   ```

2. Update handleRefine callback to:
   - Call refineAndPersistAction instead of refineAction
   - Pass parentGenerationId (the current generation._id)
   - On success, navigate to the new generation using router.replace(`/create/${result.id}`)
   - Remove local refinedCode state management (no longer needed since we navigate)

3. Updated handleRefine implementation:
   ```typescript
   const handleRefine = useCallback(
     async (prompt: string) => {
       if (!generation?._id) {
         toast.error("Cannot refine: no generation selected");
         return;
       }
       setIsRefining(true);
       try {
         const result = await refineAndPersistAction({
           parentGenerationId: generation._id,
           refinementPrompt: prompt,
           conversationHistory: [],
         });
         toast.success("Refinement saved!");
         // Navigate to the new refinement
         router.replace(`/create/${result.id}`);
       } catch (e) {
         toast.error(e instanceof Error ? e.message : "Refinement failed");
       } finally {
         setIsRefining(false);
       }
     },
     [generation, refineAndPersistAction, router]
   );
   ```

4. Remove or simplify the refinedCode state:
   - The `refinedCode` useState can be removed since we navigate to new generation
   - Remove the useEffect that resets refinedCode when generationId changes
   - Update PreviewPlayer and VideoControls to always use generation.code (no refinedCode fallback)

5. Keep the existing refineAction for potential future use (preview before save), but the primary flow now uses refineAndPersist.

Changes summary:
- Add: `const refineAndPersistAction = useAction(api.generateAnimation.refineAndPersist);`
- Update: handleRefine to call refineAndPersistAction and navigate
- Remove: refinedCode state, the useEffect that resets it
- Update: PreviewPlayer and VideoControls to not use refinedCode fallback
  </action>
  <verify>
1. Run `npx tsc --noEmit` to verify TypeScript compiles
2. Test manually:
   - Open a generation in modal
   - Submit a refinement prompt
   - Should show "Refinement saved!" toast
   - Should navigate to new generation URL
   - New generation should have parentGenerationId pointing to original
  </verify>
  <done>
- handleRefine calls refineAndPersistAction with parentGenerationId
- On success, navigates to /create/{newId}
- refinedCode local state removed (simplifies component)
- New generation appears in UI with parent link
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. TypeScript check:
   ```bash
   npx tsc --noEmit
   ```
   Should pass with no errors.

2. Convex check:
   ```bash
   npx convex dev --once
   ```
   Should show refineAndPersist action available.

3. Manual E2E test:
   a. Open app at http://localhost:3000
   b. Navigate to an existing generation
   c. Enter a refinement prompt in the input
   d. Submit the refinement
   e. Verify: Toast shows "Refinement saved!"
   f. Verify: URL changes to new generation ID
   g. Verify: In Convex dashboard, new generation has:
      - parentGenerationId pointing to original
      - refinementPrompt containing the instruction
      - status: "success"
      - code and rawCode populated
</verification>

<success_criteria>
- [ ] refineAndPersist action exists in convex/generateAnimation.ts
- [ ] refineAndPersist creates pending generation with parentGenerationId
- [ ] refineAndPersist calls Claude API and patches to success/failed
- [ ] UI calls refineAndPersist when user submits refinement
- [ ] UI navigates to new generation on successful refinement
- [ ] New generation in database has parentGenerationId set
- [ ] New generation in database has refinementPrompt set
- [ ] `npx tsc --noEmit` passes
- [ ] `npx convex dev --once` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/29-schema-refinement-persistence/29-02-SUMMARY.md`
</output>

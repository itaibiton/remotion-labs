# Phase 8: Export & Polish - Research

**Researched:** 2026-01-29
**Domain:** Client-side file generation, Remotion project scaffolding, browser downloads
**Confidence:** HIGH

## Summary

This phase adds two export capabilities: a quick single-file `.tsx` download and a full project zip scaffold. Both are client-side operations requiring no server involvement. The core challenge is transforming the existing `rawCode` (which lacks import statements by design) into standalone, runnable Remotion code.

The standard approach uses JSZip for client-side zip generation and the native Blob + anchor download pattern for file downloads. The most critical implementation detail is the code transformation layer: the generated `rawCode` intentionally omits imports (the system prompt says "don't write import statements") and uses bare API references. Export must prepend proper `import` statements and wrap the component in a `Composition` + `registerRoot` setup.

**Primary recommendation:** Use JSZip (3.10.1) for zip generation, native Blob downloads (no file-saver dependency needed), and build a deterministic code-to-standalone-file transformer that maps used APIs to proper import statements.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| jszip | 3.10.1 | Client-side zip file generation | 5,564 dependents on npm, mature (10+ years), MIT/GPLv3 dual license, works in all browsers |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| lucide-react | (already installed) | Export button icons (Download, FolderArchive) | Button UI |
| sonner | (already installed) | Toast notifications for export success/failure | User feedback |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| jszip | client-zip (2.5.0) | 40x faster, lighter (2.6kb gzipped), but fewer downloads, less battle-tested; not needed since our zips are tiny (<10KB) |
| jszip | fflate | Better performance for large files, but overkill for text-only zips |
| file-saver | Native Blob + anchor | No library needed -- native approach works in all modern browsers and the project already uses this pattern in `download-button.tsx` |

**Installation:**
```bash
npm install jszip
npm install --save-dev @types/jszip
```

Note: `@types/jszip` may not be needed if JSZip ships its own types (verify during implementation). JSZip 3.x includes TypeScript definitions.

## Architecture Patterns

### Recommended Project Structure
```
src/
├── lib/
│   ├── export-single-file.ts    # Single .tsx file generation
│   ├── export-project-zip.ts    # Full project zip generation
│   └── export-utils.ts          # Shared: import detection, code wrapping, download trigger
├── components/
│   └── export/
│       └── export-buttons.tsx   # Export UI (dropdown or two buttons)
```

### Pattern 1: Code Transformation for Export

**What:** Transform `rawCode` (import-free JSX) into standalone `.tsx` with proper imports
**When to use:** Both single-file and zip export
**Example:**

The `rawCode` from generation looks like this (NO imports, bare API references):
```jsx
// DURATION: 90
// FPS: 30

const MyComposition = () => {
  const frame = useCurrentFrame();
  const { fps } = useVideoConfig();
  const opacity = interpolate(frame, [0, 30], [0, 1], {
    extrapolateRight: 'clamp',
  });
  return (
    <AbsoluteFill style={{ backgroundColor: '#1a1a2e' }}>
      <div style={{ opacity }}>
        <h1 style={{ color: '#eee', fontSize: 80 }}>Hello World</h1>
      </div>
    </AbsoluteFill>
  );
};
```

The exported `.tsx` file must have:
```tsx
// Generated by RemotionLab
// Prompt: "bouncing hello world animation"

import React from "react";
import {
  AbsoluteFill,
  useCurrentFrame,
  useVideoConfig,
  interpolate,
  Composition,
  registerRoot,
} from "remotion";

const MyComposition: React.FC = () => {
  const frame = useCurrentFrame();
  const { fps } = useVideoConfig();
  const opacity = interpolate(frame, [0, 30], [0, 1], {
    extrapolateRight: 'clamp',
  });
  return (
    <AbsoluteFill style={{ backgroundColor: '#1a1a2e' }}>
      <div style={{ opacity }}>
        <h1 style={{ color: '#eee', fontSize: 80 }}>Hello World</h1>
      </div>
    </AbsoluteFill>
  );
};

export const RemotionRoot: React.FC = () => {
  return (
    <Composition
      id="MyComposition"
      component={MyComposition}
      durationInFrames={90}
      fps={30}
      width={1920}
      height={1080}
    />
  );
};

registerRoot(RemotionRoot);
```

### Pattern 2: API Detection via String Matching

**What:** Scan `rawCode` for known Remotion/React API usage to generate precise imports
**When to use:** Building the import statement block

The approach: maintain a map of API name to import source, scan the code for identifier usage, and build import statements from matches.

```typescript
// Map of API identifiers to their import sources
const REMOTION_APIS: Record<string, string> = {
  AbsoluteFill: "remotion",
  useCurrentFrame: "remotion",
  useVideoConfig: "remotion",
  interpolate: "remotion",
  spring: "remotion",
  Sequence: "remotion",
  Easing: "remotion",
  random: "remotion",
  Audio: "remotion",
  Img: "remotion",
  staticFile: "remotion",
  Video: "remotion",
  OffthreadVideo: "remotion",
  Series: "remotion",
  Loop: "remotion",
  Freeze: "remotion",
  Still: "remotion",
  // Always include these for the scaffold wrapper:
  Composition: "remotion",
  registerRoot: "remotion",
};

function detectUsedAPIs(code: string): string[] {
  return Object.keys(REMOTION_APIS).filter(api => {
    // Use word boundary regex to avoid false positives
    const regex = new RegExp(`\\b${api}\\b`);
    return regex.test(code);
  });
}
```

Note: This is a simple string-matching approach. It does NOT need AST parsing because:
1. The code has already been validated by the AST validator
2. We only need to detect which APIs are referenced, not validate correctness
3. Word-boundary regex is sufficient for well-formed identifiers

### Pattern 3: Remotion Project Scaffold Template

**What:** The exact files needed for a runnable Remotion project
**When to use:** Zip export

Based on the official Remotion hello-world template (verified from GitHub), a minimal standalone project needs:

```
remotionlab-export/
├── src/
│   ├── index.ts          # Entry point: registerRoot(RemotionRoot)
│   ├── Root.tsx           # Root component with <Composition> setup
│   └── MyComposition.tsx  # The user's generated component
├── package.json           # remotion + @remotion/cli + react deps
├── tsconfig.json          # TypeScript config for Remotion
└── remotion.config.ts     # Remotion CLI configuration
```

### Pattern 4: Browser Download Trigger

**What:** Trigger file download without server roundtrip
**When to use:** Both export types
**Example:**

```typescript
// Source: Existing pattern in src/components/render/download-button.tsx
function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// For single .tsx file:
function downloadTextFile(content: string, filename: string): void {
  const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
  downloadBlob(blob, filename);
}

// For zip:
async function downloadZip(zip: JSZip, filename: string): Promise<void> {
  const blob = await zip.generateAsync({ type: "blob" });
  downloadBlob(blob, filename);
}
```

### Anti-Patterns to Avoid
- **Server-side zip generation:** Unnecessary overhead for tiny text files. Client-side is simpler, faster, and avoids Convex action complexity.
- **Embedding transformed JS instead of raw JSX:** The export must use `rawCode` (JSX) not `code` (transformed JS). Users want readable, editable TypeScript/JSX.
- **Hardcoding all imports:** Don't import every possible Remotion API. Detect what's actually used and import only those.
- **Using `file-saver` library:** The native Blob + anchor approach is already used in the codebase (`download-button.tsx`) and works in all modern browsers. No need for another dependency.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Zip file generation | Custom binary zip encoding | JSZip | ZIP format is complex (compression, CRC, headers); JSZip handles it correctly |
| File download triggering | Custom download mechanism | Native Blob + anchor pattern | Already proven in codebase (`download-button.tsx`), works cross-browser |
| Remotion project template | Dynamic template generation | Static template strings | The scaffold files are fixed boilerplate; no need for dynamic generation |

**Key insight:** The only non-trivial custom code is the import detection + code wrapping layer. Everything else uses established patterns or libraries.

## Common Pitfalls

### Pitfall 1: rawCode Has No Imports
**What goes wrong:** Exporting `rawCode` directly results in code that won't compile because there are no import statements.
**Why it happens:** The generation system prompt explicitly tells Claude "don't write import statements" because APIs are pre-injected at runtime.
**How to avoid:** Always run the code through the import-prepending transformer before export. The transformer must add `import React from "react"` and all detected Remotion API imports.
**Warning signs:** Exported file starts with `// DURATION:` comment instead of import statements.

### Pitfall 2: Missing Composition Wrapper in Single-File Export
**What goes wrong:** Single `.tsx` file has the component but no `registerRoot` + `Composition`, so `npx remotion render` can't find any compositions.
**Why it happens:** The original code only defines `MyComposition` without the Remotion entry point boilerplate.
**How to avoid:** Single-file export must append `RemotionRoot` component with `<Composition>` and call `registerRoot()`. Extract `durationInFrames` and `fps` from the metadata comments.
**Warning signs:** `npx remotion render` says "No compositions found."

### Pitfall 3: DURATION/FPS Comment Stripping
**What goes wrong:** The `// DURATION: 90` and `// FPS: 30` comments are left in the exported component but also need to be extracted for the `<Composition>` props.
**Why it happens:** These metadata comments serve dual purpose: they're in the code for generation tracking AND needed as numeric values for the Composition.
**How to avoid:** Parse these values from rawCode AND optionally strip them from the component body (or leave them as documentation). Use the extracted values in the `<Composition durationInFrames={90} fps={30}>` wrapper.
**Warning signs:** Hardcoded `durationInFrames={90}` that doesn't match the actual code's duration comment.

### Pitfall 4: TypeScript Type Annotation on Component
**What goes wrong:** The exported component uses `const MyComposition = () => {` without TypeScript type, which works but isn't idiomatic TypeScript.
**Why it happens:** The generation prompt produces plain JSX without TS annotations.
**How to avoid:** Add `: React.FC` type annotation when wrapping for export: `const MyComposition: React.FC = () => {`. This is cosmetic but improves the export quality.
**Warning signs:** TypeScript strict mode warnings in the exported project.

### Pitfall 5: Remotion Version Mismatch in Scaffold
**What goes wrong:** Scaffold's `package.json` specifies a different Remotion version than what the code was generated against.
**Why it happens:** Hardcoded version strings in the template become stale.
**How to avoid:** Use the same Remotion version range as the project (`^4.0.0` is safe since Remotion follows semver within major versions). Currently the project uses `^4.0.410`.
**Warning signs:** `npm install` warnings about peer dependency conflicts.

### Pitfall 6: Object URL Memory Leak
**What goes wrong:** Creating Blob URLs without revoking them leaks memory.
**Why it happens:** Forgetting to call `URL.revokeObjectURL()` after download.
**How to avoid:** Always revoke immediately after the download is triggered. The existing `download-button.tsx` already handles this correctly (but note it doesn't revoke -- should be added).
**Warning signs:** Growing memory usage after multiple exports.

## Code Examples

### Single File Export
```typescript
// Source: Derived from project patterns + Remotion official docs

interface ExportOptions {
  rawCode: string;
  prompt: string;
  durationInFrames: number;
  fps: number;
}

function generateSingleFile({ rawCode, prompt, durationInFrames, fps }: ExportOptions): string {
  const usedAPIs = detectUsedAPIs(rawCode);

  // Always include these for the wrapper
  const wrapperAPIs = ["Composition", "registerRoot"];
  const allRemotionAPIs = [...new Set([...usedAPIs, ...wrapperAPIs])];

  // Build import block
  const remotionImports = allRemotionAPIs
    .filter(api => api !== "React")
    .join(",\n  ");

  // Strip metadata comments from component body (they become Composition props)
  const cleanedCode = rawCode
    .replace(/\/\/\s*DURATION:\s*\d+\s*\n?/, "")
    .replace(/\/\/\s*FPS:\s*\d+\s*\n?/, "")
    .trim();

  return `// Generated by RemotionLab
// Prompt: "${prompt.replace(/"/g, '\\"')}"

import React from "react";
import {
  ${remotionImports},
} from "remotion";

${cleanedCode}

export const RemotionRoot: React.FC = () => {
  return (
    <Composition
      id="MyComposition"
      component={MyComposition}
      durationInFrames={${durationInFrames}}
      fps={${fps}}
      width={1920}
      height={1080}
    />
  );
};

registerRoot(RemotionRoot);
`;
}
```

### Zip Project Scaffold
```typescript
// Source: Remotion hello-world template structure
import JSZip from "jszip";

async function generateProjectZip(options: ExportOptions): Promise<Blob> {
  const zip = new JSZip();
  const root = zip.folder("remotionlab-export")!;

  // src/MyComposition.tsx - the user's component (with imports, without registerRoot)
  root.folder("src")!.file("MyComposition.tsx", generateComponentFile(options));

  // src/Root.tsx - Composition setup
  root.folder("src")!.file("Root.tsx", generateRootFile(options));

  // src/index.ts - entry point
  root.folder("src")!.file("index.ts", generateIndexFile());

  // package.json
  root.file("package.json", generatePackageJson());

  // tsconfig.json
  root.file("tsconfig.json", generateTsConfig());

  // remotion.config.ts
  root.file("remotion.config.ts", generateRemotionConfig());

  return zip.generateAsync({ type: "blob" });
}
```

### package.json Template
```json
{
  "name": "remotionlab-export",
  "version": "1.0.0",
  "description": "Remotion video exported from RemotionLab",
  "private": true,
  "scripts": {
    "dev": "npx remotion studio",
    "render": "npx remotion render MyComposition out/video.mp4",
    "build": "npx remotion bundle"
  },
  "dependencies": {
    "@remotion/cli": "^4.0.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "remotion": "^4.0.0"
  },
  "devDependencies": {
    "@types/react": "^19",
    "typescript": "^5"
  }
}
```

### tsconfig.json Template
```json
{
  "compilerOptions": {
    "target": "ES2018",
    "module": "commonjs",
    "jsx": "react-jsx",
    "strict": true,
    "noEmit": true,
    "lib": ["es2015"],
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

### remotion.config.ts Template
```typescript
import { Config } from "@remotion/cli/config";

Config.setVideoImageFormat("jpeg");
Config.setOverwriteOutput(true);
```

### Zip File for Multi-File Export
```typescript
// Root.tsx for zip (separate from single-file)
function generateRootFile({ durationInFrames, fps }: ExportOptions): string {
  return `import React from "react";
import { Composition } from "remotion";
import { MyComposition } from "./MyComposition";

export const RemotionRoot: React.FC = () => {
  return (
    <Composition
      id="MyComposition"
      component={MyComposition}
      durationInFrames={${durationInFrames}}
      fps={${fps}}
      width={1920}
      height={1080}
    />
  );
};
`;
}

// index.ts for zip
function generateIndexFile(): string {
  return `import { registerRoot } from "remotion";
import { RemotionRoot } from "./Root";

registerRoot(RemotionRoot);
`;
}

// MyComposition.tsx for zip (component with imports + export, no registerRoot)
function generateComponentFile({ rawCode, prompt }: ExportOptions): string {
  const usedAPIs = detectUsedAPIs(rawCode);
  const remotionImports = usedAPIs.filter(api => api !== "React").join(",\n  ");

  const cleanedCode = rawCode
    .replace(/\/\/\s*DURATION:\s*\d+\s*\n?/, "")
    .replace(/\/\/\s*FPS:\s*\d+\s*\n?/, "")
    .trim();

  // Make component exported
  const exportedCode = cleanedCode.replace(
    /^const MyComposition/m,
    "export const MyComposition"
  );

  return `// Generated by RemotionLab
// Prompt: "${prompt.replace(/"/g, '\\"')}"

import React from "react";
import {
  ${remotionImports},
} from "remotion";

${exportedCode}
`;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `file-saver` for downloads | Native Blob + anchor `download` | ~2020 | No library needed, works in all modern browsers |
| Server-side zip generation | Client-side JSZip | Mature since 2015 | No server roundtrip, instant feedback, simpler architecture |
| Remotion v3 `remotion.config.ts` | Remotion v4 `@remotion/cli/config` import | v4.0 (2024) | Config import path changed from `remotion` to `@remotion/cli/config` |
| `registerRoot` import from `remotion` | Same (no change in v4) | Stable | `registerRoot` still exported from `remotion` package |

**Deprecated/outdated:**
- `Config` import from `"remotion"` -- must import from `"@remotion/cli/config"` in v4
- `Composition` `defaultProps` pattern -- replaced by `calculateMetadata` in v4, but `defaultProps` still works

## Open Questions

1. **Should metadata comments be stripped from exported component?**
   - What we know: `// DURATION: 90` and `// FPS: 30` are used for metadata extraction. In export, these values become `<Composition>` props.
   - What's unclear: Whether to keep them as documentation or strip them to avoid confusion.
   - Recommendation: Strip them from exported code. They served their purpose in the generation pipeline. In the standalone project, `durationInFrames` and `fps` are explicit `<Composition>` props.

2. **JSZip TypeScript types bundled or separate?**
   - What we know: JSZip 3.x ships with TypeScript definitions included.
   - What's unclear: Whether `@types/jszip` is still needed or redundant.
   - Recommendation: Install `jszip` only. If types aren't found, add `@types/jszip`. Verify during implementation.

3. **Single-file vs zip: should single-file include registerRoot?**
   - What we know: A single `.tsx` file with `registerRoot` can serve as both component AND entry point.
   - What's unclear: Whether users expect a single file to be directly renderable or just a component to paste into their project.
   - Recommendation: Include `registerRoot` in single-file export so it's immediately usable as `npx remotion render src/index.ts MyComposition out/video.mp4`. The CONTEXT.md says "complete entry point."

## Sources

### Primary (HIGH confidence)
- Remotion official docs: [registerRoot](https://www.remotion.dev/docs/register-root), [Composition](https://www.remotion.dev/docs/composition), [entry point](https://www.remotion.dev/docs/terminology/entry-point)
- Remotion hello-world template: [package.json](https://github.com/remotion-dev/template-helloworld/blob/main/package.json), [tsconfig.json](https://github.com/remotion-dev/template-helloworld/blob/main/tsconfig.json), [remotion.config.ts](https://github.com/remotion-dev/template-helloworld/blob/main/remotion.config.ts)
- JSZip official docs: [API examples](https://stuk.github.io/jszip/documentation/examples.html), [generateAsync](https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html)
- MDN: [URL.createObjectURL](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL_static), [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)

### Secondary (MEDIUM confidence)
- Existing codebase patterns: `src/components/render/download-button.tsx` (download trigger pattern), `convex/generateAnimation.ts` (rawCode structure), `src/lib/remotion-allowlist.ts` (API surface)

### Tertiary (LOW confidence)
- None -- all findings verified against primary sources.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - JSZip is the established solution for client-side zip generation; verified via npm and official docs
- Architecture: HIGH - Based on actual codebase analysis (rawCode format, existing download patterns, Remotion template structure)
- Pitfalls: HIGH - Derived from direct code analysis showing rawCode lacks imports, metadata comment format, and download pattern

**Research date:** 2026-01-29
**Valid until:** 2026-03-01 (stable domain -- file downloads and zip generation are mature technologies)

---
phase: 15-image-upload-input-bar
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/files.ts
  - convex/schema.ts
  - convex/generations.ts
  - convex/generateAnimation.ts
  - src/lib/image-utils.ts
autonomous: true

must_haves:
  truths:
    - "Images uploaded to Convex storage are EXIF-stripped and resized before upload"
    - "Claude receives reference images as URL-based content blocks in the user message"
    - "Generations with referenceImageIds store typed storage IDs, not plain strings"
    - "Single and multi-variation generation flows both support optional reference images"
  artifacts:
    - path: "convex/files.ts"
      provides: "generateUploadUrl mutation with auth check"
      exports: ["generateUploadUrl"]
    - path: "src/lib/image-utils.ts"
      provides: "EXIF stripping, resize, validation utilities"
      exports: ["stripExifAndResize", "validateImageFile", "ACCEPTED_IMAGE_TYPES", "MAX_IMAGES"]
    - path: "convex/schema.ts"
      provides: "referenceImageIds typed as v.id('_storage')"
      contains: "v.id(\"_storage\")"
    - path: "convex/generations.ts"
      provides: "store mutation accepting referenceImageIds as storage IDs"
      contains: "referenceImageIds"
    - path: "convex/generateAnimation.ts"
      provides: "generate and generateVariations accepting referenceImageIds, building image content blocks"
      contains: "ctx.storage.getUrl"
  key_links:
    - from: "convex/generateAnimation.ts"
      to: "ctx.storage.getUrl"
      via: "Fetches image URLs from storage IDs to build Claude content blocks"
      pattern: "ctx\\.storage\\.getUrl"
    - from: "convex/generateAnimation.ts"
      to: "internal.generations.store"
      via: "Passes referenceImageIds through to storage mutation"
      pattern: "referenceImageIds"
    - from: "convex/schema.ts"
      to: "convex/generations.ts"
      via: "Schema type change reflected in store mutation args"
      pattern: "v\\.id\\(\"_storage\"\\)"
---

<objective>
Build the backend file upload pipeline and Claude Vision integration for reference images.

Purpose: Enables the image upload feature end-to-end on the backend -- from Convex file storage URL generation, through EXIF-stripped image processing utilities, to passing uploaded images as visual context to Claude during generation. This is the foundation that the UI plans (15-02, 15-03) will call into.

Output: `convex/files.ts` (upload URL mutation), `src/lib/image-utils.ts` (client-side image processing), updated `convex/schema.ts` (typed storage IDs), updated `convex/generations.ts` (store mutation with image IDs), updated `convex/generateAnimation.ts` (Claude Vision content blocks in both generate and generateVariations).
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-image-upload-input-bar/15-RESEARCH.md
@convex/schema.ts
@convex/generateAnimation.ts
@convex/generations.ts
@src/lib/aspect-ratios.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convex file upload mutation, image utilities, and schema fix</name>
  <files>convex/files.ts, src/lib/image-utils.ts, convex/schema.ts, convex/generations.ts</files>
  <action>
**1. Create `convex/files.ts`** -- Convex file upload URL generator:

```typescript
import { mutation } from "./_generated/server";

export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Must be logged in to upload files");
    }
    return await ctx.storage.generateUploadUrl();
  },
});
```

That's the entire file. No other exports needed -- Convex handles everything else.

**2. Create `src/lib/image-utils.ts`** -- Client-side image processing utilities:

Export these:
- `ACCEPTED_IMAGE_TYPES`: Set of `"image/jpeg"`, `"image/png"`, `"image/webp"`, `"image/gif"`
- `MAX_FILE_SIZE`: 10 * 1024 * 1024 (10MB)
- `MAX_DIMENSION`: 1568 (Claude's recommended max for optimal TTFT)
- `MAX_IMAGES`: 3

- `validateImageFile(file: File): { valid: boolean; error?: string }` -- Checks file.type is in ACCEPTED_IMAGE_TYPES and file.size <= MAX_FILE_SIZE. Returns specific error messages for unsupported format (listing accepted formats) or too-large file (showing MB).

- `stripExifAndResize(file: File, maxDimension?: number): Promise<Blob>` -- Default maxDimension = MAX_DIMENSION (1568). Creates an Image element, loads file via URL.createObjectURL, calculates scaled dimensions preserving aspect ratio if either dimension exceeds maxDimension, draws onto a canvas, calls canvas.toBlob(). Output format: `"image/png"` if input is `"image/png"`, otherwise `"image/jpeg"` with quality 0.92. CRITICAL: Revoke the object URL in img.onload BEFORE drawing to canvas. Reject on img.onerror with "Failed to load image". Reject if canvas.toBlob returns null.

**3. Update `convex/schema.ts`** -- Fix referenceImageIds type:

Change line 45 from:
```typescript
referenceImageIds: v.optional(v.array(v.string())),
```
to:
```typescript
referenceImageIds: v.optional(v.array(v.id("_storage"))),
```

Update the comment from `// v0.2 Phase 15: image upload (placeholder)` to `// v0.2 Phase 15: image upload`.

**4. Update `convex/generations.ts`** -- Add referenceImageIds to store mutation:

Add to the `store` mutation args object:
```typescript
referenceImageIds: v.optional(v.array(v.id("_storage"))),
```

Add `referenceImageIds: args.referenceImageIds,` to the `ctx.db.insert("generations", {...})` call, alongside the other fields.
  </action>
  <verify>
Run `npx convex dev --once` (or check that the Convex dev server accepts the schema change without errors). Verify no TypeScript errors: `npx tsc --noEmit` passes. Confirm `convex/files.ts` exports `generateUploadUrl`, `src/lib/image-utils.ts` exports `stripExifAndResize`, `validateImageFile`, `ACCEPTED_IMAGE_TYPES`, `MAX_IMAGES`.
  </verify>
  <done>
Schema has `v.id("_storage")` for referenceImageIds. Store mutation accepts typed storage IDs. File upload URL mutation exists with auth guard. Image utility functions exist with validation and EXIF stripping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Claude Vision integration in generate and generateVariations actions</name>
  <files>convex/generateAnimation.ts</files>
  <action>
**1. Add a `buildUserContent` helper function** above the `generate` action (below the shared `generateSingleVariation` helper). This function builds the multi-part content array for Claude's Messages API:

```typescript
async function buildUserContent(
  ctx: { storage: { getUrl: (id: Id<"_storage">) => Promise<string | null> } },
  prompt: string,
  referenceImageIds?: Id<"_storage">[]
): Promise<Array<{ type: "image"; source: { type: "url"; url: string } } | { type: "text"; text: string }>> {
  const content: Array<{ type: "image"; source: { type: "url"; url: string } } | { type: "text"; text: string }> = [];

  if (referenceImageIds && referenceImageIds.length > 0) {
    for (const storageId of referenceImageIds) {
      const url = await ctx.storage.getUrl(storageId);
      if (url) {
        content.push({
          type: "image",
          source: { type: "url", url },
        });
      }
    }
  }

  content.push({ type: "text", text: prompt });
  return content;
}
```

**2. Update `generateSingleVariation` signature** to accept an optional `content` parameter as an alternative to `prompt`:

Change the signature to:
```typescript
async function generateSingleVariation(
  client: Anthropic,
  promptOrContent: string | Array<{ type: "image"; source: { type: "url"; url: string } } | { type: "text"; text: string }>,
  enhancedPrompt: string,
  temperature?: number,
): Promise<{ rawCode: string; code: string; durationInFrames: number; fps: number }>
```

In the body, change the `messages` line from:
```typescript
messages: [{ role: "user", content: prompt }],
```
to:
```typescript
messages: [{ role: "user", content: promptOrContent }],
```

This works because the Anthropic SDK's `messages` field accepts both `string` and `ContentBlock[]` for the content field.

**3. Update the `generate` action:**

Add `referenceImageIds: v.optional(v.array(v.id("_storage")))` to the args.

After building `enhancedPrompt` but before calling `generateSingleVariation`, build the content:
```typescript
const userContent = await buildUserContent(ctx, args.prompt, args.referenceImageIds);
```

Change the call to `generateSingleVariation` to pass `userContent` instead of `args.prompt`:
```typescript
const result = await generateSingleVariation(client, userContent, enhancedPrompt);
```

In the `ctx.runMutation(internal.generations.store, {...})` call, add:
```typescript
referenceImageIds: args.referenceImageIds,
```

**4. Update the `generateVariations` action:**

Add `referenceImageIds: v.optional(v.array(v.id("_storage")))` to the args.

After building `enhancedPrompt`, build the content:
```typescript
const userContent = await buildUserContent(ctx, args.prompt, args.referenceImageIds);
```

In the `variationPromises` map, change `generateSingleVariation(client, args.prompt, enhancedPrompt, temperature)` to `generateSingleVariation(client, userContent, enhancedPrompt, temperature)`.

In both the success and catch `.then`/`.catch` callbacks in `ctx.runMutation(internal.generations.store, {...})`, add:
```typescript
referenceImageIds: args.referenceImageIds,
```

**Important:** The `buildUserContent` function receives `ctx` from the action handler (which has `ctx.storage.getUrl`). This is available because `generate` and `generateVariations` are Convex actions (not mutations), so they have access to `ctx.storage`.

**Do NOT modify** the `refine` or `generateContinuation` actions -- they don't use reference images.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no TypeScript errors. Check that `generate` and `generateVariations` both accept `referenceImageIds` in their args. Check that `buildUserContent` is called in both actions. Verify the Convex dev server starts without errors.
  </verify>
  <done>
Both `generate` and `generateVariations` accept optional `referenceImageIds`, build multi-part content arrays with image URLs from Convex storage, and pass image IDs through to the store mutation. The `refine` and `generateContinuation` actions remain unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `convex/files.ts` exists and exports `generateUploadUrl`
3. `src/lib/image-utils.ts` exports `stripExifAndResize`, `validateImageFile`, `ACCEPTED_IMAGE_TYPES`, `MAX_IMAGES`
4. `convex/schema.ts` has `referenceImageIds: v.optional(v.array(v.id("_storage")))`
5. `convex/generations.ts` store mutation has `referenceImageIds: v.optional(v.array(v.id("_storage")))` in args and passes it to insert
6. `convex/generateAnimation.ts` generate action has `referenceImageIds` in args and calls `buildUserContent`
7. `convex/generateAnimation.ts` generateVariations action has `referenceImageIds` in args and calls `buildUserContent`
8. Convex dev server starts without schema or type errors
</verification>

<success_criteria>
- Schema upgraded from `v.string()` to `v.id("_storage")` for referenceImageIds
- File upload URL generation mutation exists with authentication
- Image validation and EXIF-stripping utilities exist on the client
- Claude Vision integration sends URL-based image content blocks when referenceImageIds are provided
- Both single and multi-variation generation paths support reference images
- No existing functionality broken (refine, continuation, basic generation without images)
</success_criteria>

<output>
After completion, create `.planning/phases/15-image-upload-input-bar/15-01-SUMMARY.md`
</output>

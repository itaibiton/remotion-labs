---
phase: 22-per-clip-actions
plan: 02
type: execute
wave: 1
depends_on: ["22-01"]
files_modified:
  - src/components/ui/sheet.tsx
  - src/components/movie/scene-edit-panel.tsx
  - src/components/movie/movie-editor.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking Generate Next on a timeline clip triggers continuation generation and adds result as next scene"
    - "Clicking Generate Previous on a timeline clip triggers prequel generation and inserts result before the scene"
    - "Clicking Re-generate regenerates the clip code and updates it in place"
    - "Clicking Edit opens a side panel with code editor and preview for the selected clip"
    - "User can edit code in the panel and save changes back to the clip"
  artifacts:
    - path: "src/components/ui/sheet.tsx"
      provides: "Sheet side panel component from shadcn"
      exports: ["Sheet", "SheetContent", "SheetHeader", "SheetTitle", "SheetTrigger"]
    - path: "src/components/movie/scene-edit-panel.tsx"
      provides: "SceneEditPanel with code editor and preview"
      exports: ["SceneEditPanel"]
    - path: "src/components/movie/movie-editor.tsx"
      provides: "Generation and edit handlers wired to timeline"
      exports: ["MovieEditor"]
  key_links:
    - from: "src/components/movie/movie-editor.tsx"
      to: "convex/generateAnimation.ts"
      via: "useAction hooks for generateContinuation and generatePrequel"
      pattern: "useAction.*generateContinuation|useAction.*generatePrequel"
    - from: "src/components/movie/movie-editor.tsx"
      to: "convex/movies.ts"
      via: "useMutation for insertScene"
      pattern: "useMutation.*insertScene"
    - from: "src/components/movie/movie-editor.tsx"
      to: "src/components/movie/scene-edit-panel.tsx"
      via: "renders SceneEditPanel"
      pattern: "SceneEditPanel"
---

<objective>
Wire the per-clip action handlers in MovieEditor and create the inline edit panel for code editing.

Purpose: Complete the per-clip actions workflow so users can generate continuations, prequels, regenerate clips, and edit code directly from the movie page without navigation.

Output:
- Sheet component added via shadcn
- SceneEditPanel with Monaco editor and live preview
- MovieEditor with generation handlers (handleGenerateNext, handleGeneratePrevious, handleRegenerate, handleEdit)
- Edit panel state management and save functionality
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase-specific research
@.planning/phases/22-per-clip-actions/22-RESEARCH.md

# Prior plan summary
@.planning/phases/22-per-clip-actions/22-01-SUMMARY.md

# Existing files to extend
@src/components/movie/movie-editor.tsx
@convex/generateAnimation.ts
@src/hooks/use-debounced-validation.ts
@src/components/code-editor/code-display.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Sheet component via shadcn</name>
  <files>src/components/ui/sheet.tsx</files>
  <action>
Run the shadcn CLI to add the Sheet component:

```bash
npx shadcn@latest add sheet
```

This will create `src/components/ui/sheet.tsx` with the necessary Sheet components:
- Sheet (root)
- SheetTrigger
- SheetContent
- SheetHeader
- SheetTitle
- SheetDescription
- SheetFooter
- SheetClose

If the CLI prompts for configuration, accept defaults. The component uses @radix-ui/react-dialog under the hood.
  </action>
  <verify>Verify the file exists at `src/components/ui/sheet.tsx` and exports the expected components. Run `npm run lint` to check for issues.</verify>
  <done>Sheet component exists in src/components/ui/sheet.tsx and is importable.</done>
</task>

<task type="auto">
  <name>Task 2: Create SceneEditPanel component</name>
  <files>src/components/movie/scene-edit-panel.tsx</files>
  <action>
Create a new file `src/components/movie/scene-edit-panel.tsx` with an edit panel that shows preview and code editor.

```typescript
"use client";

import { useState, useEffect } from "react";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { CodeDisplay } from "@/components/code-editor/code-display";
import { useDebouncedValidation } from "@/hooks/use-debounced-validation";
import { Player } from "@remotion/player";
import { DynamicCode } from "@/remotion/compositions/DynamicCode";

interface SceneEditPanelProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  clip: {
    _id: string;
    name: string;
    code: string;
    rawCode: string;
    durationInFrames: number;
    fps: number;
  } | null;
  onSave: (clipId: string, code: string, rawCode: string) => Promise<void>;
  isSaving?: boolean;
}

export function SceneEditPanel({
  open,
  onOpenChange,
  clip,
  onSave,
  isSaving,
}: SceneEditPanelProps) {
  const [editedCode, setEditedCode] = useState("");
  const [isEditing, setIsEditing] = useState(false);

  // Reset when clip changes
  useEffect(() => {
    if (clip) {
      setEditedCode(clip.rawCode);
      setIsEditing(false);
    }
  }, [clip?._id, clip?.rawCode]);

  // Validation hook for live preview
  const validation = useDebouncedValidation(editedCode, 500, !isEditing || !clip);

  // Use validated code for preview, fall back to original
  const previewCode = validation.isValid && validation.transformedCode
    ? validation.transformedCode
    : clip?.code ?? "";

  const handleSave = async () => {
    if (!clip || !validation.isValid || !validation.transformedCode) return;
    await onSave(clip._id, validation.transformedCode, editedCode);
    onOpenChange(false);
  };

  const hasChanges = clip && editedCode !== clip.rawCode;

  if (!clip) return null;

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent side="right" className="w-[550px] sm:max-w-[550px] flex flex-col">
        <SheetHeader className="flex-shrink-0">
          <SheetTitle className="truncate">Edit: {clip.name}</SheetTitle>
        </SheetHeader>

        <div className="flex flex-col gap-4 mt-4 flex-1 min-h-0">
          {/* Preview player */}
          <div className="h-[180px] flex-shrink-0 bg-black rounded-lg overflow-hidden">
            <Player
              component={DynamicCode}
              inputProps={{
                code: previewCode,
                durationInFrames: clip.durationInFrames,
                fps: clip.fps,
              }}
              compositionWidth={1920}
              compositionHeight={1080}
              durationInFrames={clip.durationInFrames}
              fps={clip.fps}
              style={{ width: "100%", height: "100%" }}
              controls
              loop
            />
          </div>

          {/* Code editor */}
          <div className="flex-1 min-h-0 overflow-hidden">
            <CodeDisplay
              code={editedCode}
              originalCode={clip.rawCode}
              isEditing={isEditing}
              onEditToggle={() => setIsEditing(!isEditing)}
              onChange={setEditedCode}
              errors={validation.errors}
              isValid={validation.isValid}
            />
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-2 flex-shrink-0 pt-2 border-t">
            <Button
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isSaving}
            >
              Cancel
            </Button>
            <Button
              onClick={handleSave}
              disabled={!validation.isValid || !hasChanges || isSaving}
            >
              {isSaving ? "Saving..." : "Save Changes"}
            </Button>
          </div>
        </div>
      </SheetContent>
    </Sheet>
  );
}
```

Key implementation notes:
- Uses Sheet from shadcn (side="right" for right-side panel)
- Reuses existing `CodeDisplay` component and `useDebouncedValidation` hook
- Live preview updates as user edits (when validation passes)
- Save button disabled when no changes or validation fails
- Panel width 550px to fit both preview and editor
  </action>
  <verify>Run `npm run lint` and `npm run build` to check for TypeScript errors.</verify>
  <done>SceneEditPanel renders Sheet with preview player and code editor, Save button works.</done>
</task>

<task type="auto">
  <name>Task 3: Wire generation and edit handlers in MovieEditor</name>
  <files>src/components/movie/movie-editor.tsx</files>
  <action>
Update MovieEditor to add generation action handlers and edit panel state.

1. **Add imports** at the top:
```typescript
import { useAction } from "convex/react";
import { SceneEditPanel } from "./scene-edit-panel";
```

2. **Add Convex hooks** after existing mutations (inside the component):
```typescript
const continuationAction = useAction(api.generateAnimation.generateContinuation);
const prequelAction = useAction(api.generateAnimation.generatePrequel);
const saveClip = useMutation(api.clips.save);
const updateClip = useMutation(api.clips.update);
const insertScene = useMutation(api.movies.insertScene);
```

3. **Add state** for generation and edit panel:
```typescript
const [generatingSceneIndex, setGeneratingSceneIndex] = useState<number | null>(null);
const [editingSceneIndex, setEditingSceneIndex] = useState<number | null>(null);
const [isSavingEdit, setIsSavingEdit] = useState(false);
```

4. **Add handler functions** (after the existing handlers, before early returns):

```typescript
// Generate continuation and insert as next scene
const handleGenerateNext = useCallback(async (sceneIndex: number) => {
  if (!movie || generatingSceneIndex !== null) return;
  const scene = scenesWithClips[sceneIndex];
  if (!scene?.clip) return;

  setGeneratingSceneIndex(sceneIndex);
  try {
    toast.loading("Generating continuation...", { id: "gen-next" });

    // 1. Generate continuation code
    const result = await continuationAction({
      sourceClipId: scene.clip._id as any,
    });

    // 2. Save as new clip
    const newClipId = await saveClip({
      name: `${scene.clip.name} (cont.)`,
      code: result.code,
      rawCode: result.rawCode,
      durationInFrames: result.durationInFrames,
      fps: result.fps,
    });

    // 3. Insert into movie after source scene
    await insertScene({
      movieId: movie._id as any,
      clipId: newClipId as any,
      afterIndex: sceneIndex,
    });

    toast.success("Continuation added!", { id: "gen-next" });
  } catch (error) {
    toast.error(error instanceof Error ? error.message : "Failed to generate", { id: "gen-next" });
  } finally {
    setGeneratingSceneIndex(null);
  }
}, [movie, scenesWithClips, generatingSceneIndex, continuationAction, saveClip, insertScene]);

// Generate prequel and insert before scene
const handleGeneratePrevious = useCallback(async (sceneIndex: number) => {
  if (!movie || generatingSceneIndex !== null) return;
  const scene = scenesWithClips[sceneIndex];
  if (!scene?.clip) return;

  setGeneratingSceneIndex(sceneIndex);
  try {
    toast.loading("Generating prequel...", { id: "gen-prev" });

    // 1. Generate prequel code
    const result = await prequelAction({
      sourceClipId: scene.clip._id as any,
    });

    // 2. Save as new clip
    const newClipId = await saveClip({
      name: `${scene.clip.name} (prequel)`,
      code: result.code,
      rawCode: result.rawCode,
      durationInFrames: result.durationInFrames,
      fps: result.fps,
    });

    // 3. Insert into movie BEFORE source scene
    await insertScene({
      movieId: movie._id as any,
      clipId: newClipId as any,
      beforeIndex: sceneIndex,
    });

    toast.success("Prequel added!", { id: "gen-prev" });
  } catch (error) {
    toast.error(error instanceof Error ? error.message : "Failed to generate", { id: "gen-prev" });
  } finally {
    setGeneratingSceneIndex(null);
  }
}, [movie, scenesWithClips, generatingSceneIndex, prequelAction, saveClip, insertScene]);

// Regenerate clip code in place
const handleRegenerate = useCallback(async (sceneIndex: number) => {
  if (!movie || generatingSceneIndex !== null) return;
  const scene = scenesWithClips[sceneIndex];
  if (!scene?.clip) return;

  setGeneratingSceneIndex(sceneIndex);
  try {
    toast.loading("Regenerating clip...", { id: "regen" });

    // Use continuation action with the clip's own code as source for regeneration
    // This generates a fresh variation based on the same visual style
    const result = await continuationAction({
      sourceClipId: scene.clip._id as any,
      prompt: "Create a fresh variation with similar style but different animation",
    });

    // Update the existing clip with new code
    await updateClip({
      id: scene.clip._id as any,
      code: result.code,
      rawCode: result.rawCode,
      durationInFrames: result.durationInFrames,
      fps: result.fps,
    });

    toast.success("Clip regenerated!", { id: "regen" });
  } catch (error) {
    toast.error(error instanceof Error ? error.message : "Failed to regenerate", { id: "regen" });
  } finally {
    setGeneratingSceneIndex(null);
  }
}, [movie, scenesWithClips, generatingSceneIndex, continuationAction, updateClip]);

// Open edit panel for a scene
const handleEdit = useCallback((sceneIndex: number) => {
  setEditingSceneIndex(sceneIndex);
}, []);

// Save edited clip code
const handleSaveEdit = useCallback(async (clipId: string, code: string, rawCode: string) => {
  setIsSavingEdit(true);
  try {
    await updateClip({
      id: clipId as any,
      code,
      rawCode,
    });
    toast.success("Changes saved");
  } catch (error) {
    toast.error(error instanceof Error ? error.message : "Failed to save");
    throw error; // Re-throw so panel knows save failed
  } finally {
    setIsSavingEdit(false);
  }
}, [updateClip]);

// Get the clip being edited
const editingClip = editingSceneIndex !== null
  ? scenesWithClips[editingSceneIndex]?.clip ?? null
  : null;
```

5. **Update Timeline component call** to pass the handlers:
```typescript
<Timeline
  scenes={scenesWithClips}
  activeSceneIndex={activeSceneIndex}
  totalDurationInFrames={totalDurationInFrames}
  fps={movie.fps}
  playerRef={playerRef}
  onReorder={handleReorder}
  onRemove={handleRemoveScene}
  onTrimScene={handleTrimScene}
  isBladeMode={isBladeMode}
  onToggleBladeMode={toggleBladeMode}
  onSplit={handleSplitAtPlayhead}
  onGenerateNext={handleGenerateNext}
  onGeneratePrevious={handleGeneratePrevious}
  onRegenerate={handleRegenerate}
  onEdit={handleEdit}
  isGenerating={generatingSceneIndex !== null}
/>
```

6. **Add SceneEditPanel** after AddScenePanel at the end of the component return:
```typescript
{/* Edit Scene Panel */}
<SceneEditPanel
  open={editingSceneIndex !== null}
  onOpenChange={(open) => {
    if (!open) setEditingSceneIndex(null);
  }}
  clip={editingClip}
  onSave={handleSaveEdit}
  isSaving={isSavingEdit}
/>
```
  </action>
  <verify>Run `npm run lint` and `npm run build` to check for TypeScript errors. Start the dev server and test on the movie page.</verify>
  <done>All four action handlers work: Generate Next adds continuation after scene, Generate Previous adds prequel before scene, Re-generate updates clip in place, Edit opens side panel with working save.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds without errors
2. `npm run lint` passes
3. On movie page with scenes:
   - Hover over a timeline clip shows the actions dropdown menu
   - Click "Generate Next" → loading toast → continuation clip added after the scene
   - Click "Generate Previous" → loading toast → prequel clip inserted before the scene
   - Click "Re-generate" → loading toast → clip code updated, preview refreshes
   - Click "Edit" → side panel opens with preview player and code editor
   - Edit code in panel, click Save → changes persist, panel closes
4. Actions are disabled while generation is in progress
5. Error cases show toast error messages
</verification>

<success_criteria>
- Sheet component exists and is used by SceneEditPanel
- SceneEditPanel shows live preview and Monaco editor for selected clip
- handleGenerateNext generates continuation and inserts after source scene via insertScene mutation
- handleGeneratePrevious generates prequel and inserts before source scene
- handleRegenerate updates existing clip via clips.update mutation
- handleEdit opens SceneEditPanel with correct clip data
- Save in edit panel persists changes via clips.update
- Loading states prevent double-click issues
- Toast feedback for all operations
</success_criteria>

<output>
After completion, create `.planning/phases/22-per-clip-actions/22-02-SUMMARY.md`
</output>

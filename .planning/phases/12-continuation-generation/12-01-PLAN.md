---
phase: 12-continuation-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/generateAnimation.ts
autonomous: true

must_haves:
  truths:
    - "System can analyze a clip's rawCode and generate a continuation composition via Claude"
    - "Continuation code passes the existing validation and transformation pipeline"
    - "generateContinuation action accepts sourceClipId and optional prompt, returns rawCode + code + timing"
  artifacts:
    - path: "convex/generateAnimation.ts"
      provides: "generateContinuation action + CONTINUATION_SYSTEM_PROMPT const"
      exports: ["generate", "refine", "generateContinuation"]
      contains: "CONTINUATION_SYSTEM_PROMPT"
  key_links:
    - from: "convex/generateAnimation.ts (generateContinuation)"
      to: "convex/clips.ts (getInternal)"
      via: "ctx.runQuery(internal.clips.getInternal)"
      pattern: "internal\\.clips\\.getInternal"
    - from: "convex/generateAnimation.ts (generateContinuation)"
      to: "Anthropic API"
      via: "client.messages.create with CONTINUATION_SYSTEM_PROMPT"
      pattern: "CONTINUATION_SYSTEM_PROMPT"
---

<objective>
Create the continuation generation backend: a specialized Claude system prompt for scene continuation and a Convex action that fetches a source clip's rawCode, sends it to Claude with the continuation prompt, and returns validated/transformed continuation code.

Purpose: This is the core novel work of Phase 12 -- enabling Claude to read animation code, determine its visual end state, and generate a new composition that starts from that end state. Everything else in this phase is UI that calls this action.

Output: `CONTINUATION_SYSTEM_PROMPT` const and `generateContinuation` action added to `convex/generateAnimation.ts`, following the same inlined pattern as the existing `SYSTEM_PROMPT` and `REFINEMENT_SYSTEM_PROMPT`.
</objective>

<execution_context>
@/Users/Kohelet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Kohelet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-continuation-generation/12-RESEARCH.md

@convex/generateAnimation.ts
@convex/clips.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CONTINUATION_SYSTEM_PROMPT const to generateAnimation.ts</name>
  <files>convex/generateAnimation.ts</files>
  <action>
Add a new `CONTINUATION_SYSTEM_PROMPT` const to `convex/generateAnimation.ts`, placed between the existing `REFINEMENT_SYSTEM_PROMPT` section and the `generate` action. Follow the file's section comment pattern (`// ============...`).

Add a section header:
```
// ============================================================================
// Continuation System Prompt
// ============================================================================
```

The prompt must be a template literal string instructing Claude to:

**STEP 1 -- ANALYZE the previous scene's FINAL VISUAL STATE:**
- Read the `// DURATION` comment to know total frames (the "last frame" number)
- For each `interpolate(frame, [inputStart, inputEnd], [outputStart, outputEnd])`: determine the output value at the last frame. If the last frame >= inputEnd, the output is outputEnd (or clamped if `extrapolateRight: 'clamp'`)
- For each `spring({frame, fps, ...})`: the settled value is the `to` param (default 1.0)
- Identify ALL visual properties at the last frame: positions (transform: translate, top/left, flex alignment), opacity, scale, rotation, colors (backgroundColor, color, borderColor), font sizes, text content, which elements are visible (opacity > 0)

**STEP 2 -- Add a comment block at the top of the output:**
```
// CONTINUATION FROM PREVIOUS SCENE
// End state: [brief description of the final visual state]
// DURATION: [frames, between 60-180]
// FPS: 30
```

**STEP 3 -- GENERATE a new composition where:**
- The FIRST FRAME (frame 0) is VISUALLY IDENTICAL to the previous scene's last frame
- All initial values before any interpolation match the previous scene's end-state values
- The same layout approach is used (AbsoluteFill, flex centering, etc.)
- The same coordinate system and positioning approach
- Consistent styling (font families, color palettes) unless the user requests changes
- Then animates FROM those starting values to new values based on the user's prompt
- If no specific user prompt, creates a natural, visually interesting continuation

**CRITICAL RULES (must match existing SYSTEM_PROMPT rules):**
- Component must be named "MyComposition"
- Do NOT use import statements (APIs are pre-injected)
- Output ONLY valid JSX code. No markdown, no explanations, no code blocks
- Available APIs: React, useState, useEffect, useMemo, useCallback, AbsoluteFill, useCurrentFrame, useVideoConfig, interpolate, spring, Sequence, Easing, random, Audio, Img, staticFile, Video, OffthreadVideo, Composition, Still, Series, Loop, Freeze
- FORBIDDEN: import/require, eval, Function, setTimeout, setInterval, fetch, XMLHttpRequest, WebSocket, document, window, process
- Use FPS 30. Duration between 60-180 frames.

**Include a concrete EXAMPLE** (use the example from 12-RESEARCH.md Example 1): If previous scene ends with white text "Hello" centered at opacity 1, scale 1.2, backgroundColor '#1a1a2e', the continuation should start with those exact values and transition to new content.

Reference the research file's "Example 1: Continuation System Prompt" section for the full prompt text. Adapt it to match the exact formatting style of `SYSTEM_PROMPT` and `REFINEMENT_SYSTEM_PROMPT` already in the file.
  </action>
  <verify>
Grep `convex/generateAnimation.ts` for "CONTINUATION_SYSTEM_PROMPT" -- should find the const definition. Run `npx tsc --noEmit` to confirm no syntax errors.
  </verify>
  <done>
`CONTINUATION_SYSTEM_PROMPT` const is defined in `convex/generateAnimation.ts` with comprehensive instructions for end-state analysis and continuation generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add generateContinuation action</name>
  <files>convex/generateAnimation.ts</files>
  <action>
Add a new exported `generateContinuation` action at the end of `convex/generateAnimation.ts`, after the existing `refine` action. Add a section header:

```
// ============================================================================
// Continuation Generation Action
// ============================================================================
```

Action signature:
```typescript
export const generateContinuation = action({
  args: {
    sourceClipId: v.id("clips"),
    prompt: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<{
    rawCode: string;
    code: string;
    durationInFrames: number;
    fps: number;
  }> => { ... }
});
```

Implementation (follow the `generate` action's pattern exactly):

1. **Auth check:** `const identity = await ctx.auth.getUserIdentity();` -- throw `"You must be logged in to generate continuations"` if null.

2. **Fetch source clip:** `const sourceClip = await ctx.runQuery(internal.clips.getInternal, { id: args.sourceClipId });` -- throw `"Source clip not found"` if null. Verify `sourceClip.rawCode` exists.

3. **Create Anthropic client:** Same pattern as `generate` -- check `process.env.ANTHROPIC_API_KEY`, create `new Anthropic({ apiKey })`.

4. **Build user message:**
   - With prompt: `"PREVIOUS SCENE CODE:\n\`\`\`\n${sourceClip.rawCode}\n\`\`\`\n\nGenerate the next scene: ${args.prompt}"`
   - Without prompt: `"PREVIOUS SCENE CODE:\n\`\`\`\n${sourceClip.rawCode}\n\`\`\`\n\nGenerate a natural, visually interesting continuation."`

5. **Call Claude:** `client.messages.create({ model: "claude-sonnet-4-5-20250929", max_tokens: 4096, system: CONTINUATION_SYSTEM_PROMPT, messages: [{ role: "user", content: userContent }] })`

6. **Post-process** (copy the exact logic from the `generate` action):
   - Extract text content: `response.content.find((block) => block.type === "text")`
   - Strip markdown code blocks if present (same regex as generate)
   - Preserve as `rawCode`
   - Extract `// DURATION` and `// FPS` comments
   - Clamp: `durationInFrames = Math.min(Math.max(rawDuration, 30), 600)`, `fps = 30`
   - Validate: `validateRemotionCode(rawCode)` -- throw with error message if invalid
   - Transform: `transformJSX(rawCode)` -- throw if failed
   - Return `{ rawCode, code: transformed.code, durationInFrames, fps }`

**Key differences from `generate`:**
- Does NOT store in database (no `ctx.runMutation` call) -- like `refine`, returns result directly
- Uses `CONTINUATION_SYSTEM_PROMPT` instead of `SYSTEM_PROMPT`
- Fetches source clip code as context for the prompt
  </action>
  <verify>
Run `npx tsc --noEmit` for type checking. Grep for `export const generateContinuation` in `convex/generateAnimation.ts`. The Convex function should be accessible as `api.generateAnimation.generateContinuation` from the frontend.
  </verify>
  <done>
`generateContinuation` action is exported and callable. It accepts `{ sourceClipId, prompt? }`, fetches the source clip's rawCode via `internal.clips.getInternal`, calls Claude with `CONTINUATION_SYSTEM_PROMPT`, validates and transforms the output, and returns `{ rawCode, code, durationInFrames, fps }`.
  </done>
</task>

</tasks>

<verification>
1. `convex/generateAnimation.ts` exports three actions: `generate`, `refine`, `generateContinuation`
2. `CONTINUATION_SYSTEM_PROMPT` is defined inline as a const in the same file
3. The action uses `internal.clips.getInternal` to fetch the source clip
4. The action reuses the inlined `validateRemotionCode` and `transformJSX` functions
5. `npx tsc --noEmit` passes with no errors
6. Convex dev server accepts the new code without deployment errors
</verification>

<success_criteria>
- generateContinuation action exists and is callable from the frontend via `useAction(api.generateAnimation.generateContinuation)`
- The action follows the same auth, validation, and transformation patterns as generate/refine
- The continuation system prompt instructs Claude to analyze end state and generate visually continuous code
- No new dependencies introduced
- No new files created (everything inlined in existing file, consistent with codebase patterns)
</success_criteria>

<output>
After completion, create `.planning/phases/12-continuation-generation/12-01-SUMMARY.md`
</output>
